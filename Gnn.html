<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAGECéœ²å¤©çŸ¿æ™ºèƒ½è¿è¾“åè°ƒç³»ç»Ÿ (è®ºæ–‡ä¼˜åŒ–ç‰ˆ)</title>
    
    <!-- TensorFlow.js for GPU-accelerated AI -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Consolas', monospace;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }

        .main-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .side-panel {
            width: 380px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }

        .title {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #network-canvas {
            width: 100%;
            height: calc(100vh - 120px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.95);
            cursor: crosshair;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .btn.active {
            background: linear-gradient(145deg, #f093fb, #f5576c);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .stats {
            font-size: 10px;
            line-height: 1.3;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            white-space: pre-line;
            font-family: 'Courier New', monospace;
            max-height: calc(50vh);
            overflow-y: auto;
        }

        .magec-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .ai-panel {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .ai-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #4CAF50;
            font-size: 12px;
        }

        .progress-bar {
            width: 100%;
            height: 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            margin: 5px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
            border-radius: 8px;
        }

        .ai-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 10px;
        }

        .metric-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px;
            border-radius: 4px;
        }

        .legend {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .warmup-indicator {
            background: rgba(255, 152, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            margin: 5px 0;
            text-align: center;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        .gpu-status {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            border-radius: 6px;
            padding: 8px;
            margin: 5px 0;
            font-size: 10px;
        }

        .coordination-metrics {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid #2196F3;
            border-radius: 6px;
            padding: 8px;
            margin: 5px 0;
            font-size: 10px;
        }

        .debug-panel {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #f44336;
            border-radius: 6px;
            padding: 8px;
            margin: 5px 0;
            font-size: 10px;
            color: #ffcdd2;
        }

        .mining-optimization-panel {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #FFC107;
            border-radius: 6px;
            padding: 8px;
            margin: 5px 0;
            font-size: 10px;
            color: #FFF8E1;
        }

        .mining-optimization-panel .panel-title {
            font-weight: bold;
            margin-bottom: 4px;
            color: #FFC107;
        }
    </style>
</head>
<body>
    <div class="magec-indicator" id="magecIndicator">ğŸš› MAGECéœ²å¤©çŸ¿AIå­¦ä¹ ä¸­</div>
    
    <div class="container">
        <div class="main-panel">
            <div class="title">
                ğŸš› MAGECéœ²å¤©çŸ¿æ™ºèƒ½è¿è¾“åè°ƒç³»ç»Ÿ (è®ºæ–‡ä¼˜åŒ–ç‰ˆ)
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">
                    åŸºäºGraphSAGEçš„å¤šæ™ºèƒ½ä½“å¼ºåŒ–å­¦ä¹  | ä¸“ä¸šå†²çªé¿å…ä¸æ•ˆç‡ä¼˜åŒ–
                </div>
            </div>
            <canvas id="network-canvas"></canvas>
            <div class="controls">
                <button class="btn" id="startBtn">â–¶ï¸ å¼€å§‹</button>
                <button class="btn" id="pauseBtn">â¸ï¸ æš‚åœ</button>
                <button class="btn" id="resetBtn">ğŸ”„ é‡ç½®</button>
                <button class="btn active" id="magecBtn">ğŸ§  MAGEC</button>
                <button class="btn" id="traditionalBtn">âš™ï¸ ä¼ ç»Ÿ</button>
                <button class="btn" id="trainBtn">ğŸ“ è®­ç»ƒ</button>
                <button class="btn" id="addBtn">â• æ·»åŠ è½¦è¾†</button>
                <button class="btn" id="removeBtn">â– ç§»é™¤è½¦è¾†</button>
                <button class="btn" id="speedBtn">âš¡ é€Ÿåº¦: 1x</button>
            </div>
        </div>

        <div class="side-panel">
            <!-- GPUçŠ¶æ€é¢æ¿ -->
            <div class="gpu-status" id="gpu-status">
                <div style="font-weight: bold; margin-bottom: 4px;">ğŸ® GPUçŠ¶æ€</div>
                <div>åç«¯: <span id="tf-backend">æ£€æµ‹ä¸­...</span></div>
                <div>å†…å­˜ä½¿ç”¨: <span id="gpu-memory">0 MB</span></div>
                <div>Tensors: <span id="tensor-count">0</span></div>
            </div>

            <!-- éœ²å¤©çŸ¿ä¼˜åŒ–é¢æ¿ -->
            <div class="mining-optimization-panel" id="mining-optimization">
                <div class="panel-title">ğŸ—ï¸ éœ²å¤©çŸ¿è¿è¾“ä¼˜åŒ–</div>
                <div>è¿è¾“æ•ˆç‡: <span id="transport-efficiency">0%</span></div>
                <div>å¹³å‡å‘¨æœŸæ—¶é—´: <span id="avg-cycle-time">0.0s</span></div>
                <div>è£…è½½ç‚¹åˆ©ç”¨ç‡: <span id="loading-utilization">0%</span></div>
                <div>å¸è½½ç‚¹åˆ©ç”¨ç‡: <span id="unloading-utilization">0%</span></div>
                <div>è·¯å¾„ä¼˜åŒ–å¾—åˆ†: <span id="path-optimization">0%</span></div>
            </div>

            <!-- Debugé¢æ¿ -->
            <div class="debug-panel" id="debug-panel">
                <div style="font-weight: bold; margin-bottom: 4px;">ğŸ”§ è°ƒè¯•ä¿¡æ¯</div>
                <div>MAGECå°±ç»ª: <span id="debug-ready">false</span></div>
                <div>ç»éªŒæ•°æ®: <span id="debug-experiences">0</span></div>
                <div>æœ€å°éœ€æ±‚: <span id="debug-min-exp">0</span></div>
                <div>AIå†³ç­–æ•°: <span id="debug-decisions">0</span></div>
                <div>å¥–åŠ±ç±»å‹: <span id="debug-reward-type">Mining</span></div>
            </div>

            <!-- åè°ƒæŒ‡æ ‡ -->
            <div class="coordination-metrics" id="coordination-metrics">
                <div style="font-weight: bold; margin-bottom: 4px;">ğŸ¤ åè°ƒæŒ‡æ ‡</div>
                <div>å†²çªé¿å…: <span id="conflict-avoided">0</span></div>
                <div>é¢„è®¢æˆåŠŸ: <span id="reservations-made">0</span></div>
                <div>ä»»åŠ¡å®Œæˆ: <span id="tasks-completed">0</span></div>
                <div>å¹³å‡ç­‰å¾…: <span id="avg-wait">0.0s</span></div>
            </div>

            <!-- é¢„çƒ­æŒ‡ç¤ºå™¨ -->
            <div class="warmup-indicator" id="warmup-indicator" style="display: none;">
                ğŸ”„ é¢„çƒ­é˜¶æ®µï¼šå­¦ä¹ åŸºç¡€è¡Œä¸ºæ¨¡å¼... <span id="warmup-progress">0%</span>
            </div>

            <!-- AIè®­ç»ƒé¢æ¿ -->
            <div class="ai-panel">
                <div class="ai-title">ğŸ“ MAGECè®­ç»ƒè¿›åº¦ (è®ºæ–‡ä¼˜åŒ–ç‰ˆ)</div>
                <div>Episode: <span id="episode-count">0</span> / <span id="max-episodes">2000</span></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="training-progress" style="width: 0%"></div>
                </div>
                <div class="ai-metrics">
                    <div class="metric-item">
                        å¹³å‡å¥–åŠ±: <span id="avg-reward">0.000</span>
                    </div>
                    <div class="metric-item">
                        åè°ƒå¾—åˆ†: <span id="coordination-score">0%</span>
                    </div>
                    <div class="metric-item">
                        AIå†³ç­–: <span id="ai-decisions">0</span>
                    </div>
                    <div class="metric-item">
                        å†²çªç‡: <span id="conflict-rate">0%</span>
                    </div>
                    <div class="metric-item">
                        å­¦ä¹ ç‡: <span id="learning-rate">0.0003</span>
                    </div>
                    <div class="metric-item">
                        ç»éªŒæ•°æ®: <span id="experience-count">0</span>
                    </div>
                </div>
            </div>

            <!-- å›¾ä¾‹ -->
            <div class="legend">
                <div style="font-weight: bold; margin-bottom: 8px;">ğŸ“‹ ç³»ç»Ÿå›¾ä¾‹</div>
                
                <div style="font-weight: bold; margin: 8px 0 4px 0;">è¿è¾“å¾ªç¯:</div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9E9E9E;"></div>
                    ğŸ…¿ï¸ åœè½¦åœº (èµ·å§‹ç‚¹)
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    ğŸŸ¢ è£…è½½ç‚¹ (å–è´§)
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    ğŸ”µ å¸è½½ç‚¹ (é€è´§)
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9E9E9E;"></div>
                    ğŸ”„ è¿”å›åœè½¦åœº
                </div>

                <div style="font-weight: bold; margin: 8px 0 4px 0;">AIå­¦ä¹ é‡ç‚¹:</div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    ğŸ§  å†²çªé¿å… (GraphSAGE)
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF9800;"></div>
                    ğŸ¤ èµ„æºåè°ƒ (Neighbor Scoring)
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9C27B0;"></div>
                    â° æ—¶ç©ºä¼˜åŒ– (MAPPO)
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #F44336;"></div>
                    ğŸš« æ­»é”é˜²æ­¢ (Multi-Path)
                </div>
            </div>

            <!-- ç³»ç»Ÿç»Ÿè®¡ -->
            <div class="stats" id="stats">
                <span style="color: #4CAF50;">â—</span> MAGECéœ²å¤©çŸ¿ç³»ç»Ÿåˆå§‹åŒ–ä¸­...
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // å…¨å±€å˜é‡å£°æ˜
        // ============================================================================
        
        let simulation;
        let gpuInitialized = false;
        let gpuMonitorInterval = null;
        
        // ============================================================================
        // GPUä¼˜åŒ–é…ç½® (ä¿ç•™åŸæœ‰ä»£ç )
        // ============================================================================
        
        async function initializeGPU() {
            if (gpuInitialized) return;
            
            console.log('ğŸ® å¼€å§‹åˆå§‹åŒ–GPUåŠ é€Ÿ...');
            
            const backendElement = document.getElementById('tf-backend');
            if (!backendElement) {
                console.warn('âš ï¸ DOMå…ƒç´ æœªå°±ç»ªï¼Œå»¶è¿ŸGPUåˆå§‹åŒ–');
                setTimeout(() => initializeGPU(), 100);
                return;
            }
            
            updateGPUStatus('åˆå§‹åŒ–ä¸­...', '0 MB', '0');
            
            try {
                console.log('ğŸ”„ è®¾ç½®WebGLåç«¯...');
                await tf.setBackend('webgl');
                console.log('ğŸ”„ ç­‰å¾…TensorFlow.jså°±ç»ª...');
                await tf.ready();
                
                gpuInitialized = true;
                const backend = tf.getBackend();
                console.log('âœ… GPUåˆå§‹åŒ–å®Œæˆï¼Œåç«¯:', backend);
                
                updateGPUStatus();
                
                if (!gpuMonitorInterval) {
                    gpuMonitorInterval = setInterval(() => {
                        try {
                            updateGPUStatus();
                        } catch (error) {
                            console.warn('GPUçŠ¶æ€æ›´æ–°é”™è¯¯:', error);
                        }
                    }, 1000);
                }
                
            } catch (error) {
                console.error('âŒ WebGLåˆå§‹åŒ–å¤±è´¥ï¼Œå›é€€åˆ°CPU:', error);
                try {
                    await tf.setBackend('cpu');
                    await tf.ready();
                    gpuInitialized = true;
                    console.log('âœ… CPUåç«¯åˆå§‹åŒ–å®Œæˆ');
                    updateGPUStatus();
                    
                    if (!gpuMonitorInterval) {
                        gpuMonitorInterval = setInterval(() => {
                            try {
                                updateGPUStatus();
                            } catch (error) {
                                console.warn('GPUçŠ¶æ€æ›´æ–°é”™è¯¯:', error);
                            }
                        }, 1000);
                    }
                } catch (cpuError) {
                    console.error('âŒ CPUåç«¯ä¹Ÿåˆå§‹åŒ–å¤±è´¥:', cpuError);
                    updateGPUStatus('åˆå§‹åŒ–å¤±è´¥', '0 MB', '0');
                }
            }
        }
        
        function updateGPUStatus(customBackend = null, customMemory = null, customTensors = null) {
            try {
                const backendElement = document.getElementById('tf-backend');
                const memoryElement = document.getElementById('gpu-memory');
                const tensorElement = document.getElementById('tensor-count');
                
                if (!backendElement || !memoryElement || !tensorElement) {
                    console.warn('âš ï¸ GPUçŠ¶æ€å…ƒç´ æœªæ‰¾åˆ°');
                    return;
                }
                
                if (customBackend) {
                    backendElement.textContent = customBackend;
                    memoryElement.textContent = customMemory || '0 MB';
                    tensorElement.textContent = customTensors || '0';
                } else if (typeof tf !== 'undefined' && tf.getBackend) {
                    const memInfo = tf.memory();
                    const backend = tf.getBackend().toUpperCase();
                    
                    backendElement.textContent = backend;
                    memoryElement.textContent = `${(memInfo.numBytes / 1024 / 1024).toFixed(1)} MB`;
                    tensorElement.textContent = memInfo.numTensors.toString();
                } else {
                    backendElement.textContent = 'TF.jsæœªåŠ è½½';
                    memoryElement.textContent = '0 MB';
                    tensorElement.textContent = '0';
                }
            } catch (error) {
                console.error('updateGPUStatusé”™è¯¯:', error);
                const backendElement = document.getElementById('tf-backend');
                if (backendElement) {
                    backendElement.textContent = 'çŠ¶æ€é”™è¯¯';
                }
            }
        }

        // ============================================================================
        // éœ²å¤©çŸ¿ä¸“ç”¨å¥–åŠ±ç³»ç»Ÿ (æ–°å¢)
        // ============================================================================

        class MiningTransportRewardSystem {
            constructor() {
                this.weights = {
                    taskCompletion: 2.0,
                    efficiency: 1.5,
                    conflictAvoidance: 3.0,
                    coordination: 1.0,
                    waitTimePenalty: -2.0,
                    systemThroughput: 1.2
                };
                
                this.benchmarks = {
                    optimalCycleTime: 30.0,
                    maxWaitTime: 5.0,
                    minThroughput: 0.1
                };
            }

            calculateReward(vehicle, currentTime, conflictAvoided, coordinationScore, systemStats) {
                let totalReward = 0;
                let rewardBreakdown = {};

                // 1. ä»»åŠ¡å®Œæˆå¥–åŠ±
                const taskReward = this.calculateTaskCompletionReward(vehicle, currentTime);
                totalReward += this.weights.taskCompletion * taskReward;
                rewardBreakdown.taskCompletion = taskReward;

                // 2. è¿è¾“æ•ˆç‡å¥–åŠ±
                const efficiencyReward = this.calculateEfficiencyReward(vehicle, currentTime);
                totalReward += this.weights.efficiency * efficiencyReward;
                rewardBreakdown.efficiency = efficiencyReward;

                // 3. å†²çªé¿å…å¥–åŠ±
                const conflictReward = this.calculateConflictAvoidanceReward(vehicle, conflictAvoided);
                totalReward += this.weights.conflictAvoidance * conflictReward;
                rewardBreakdown.conflictAvoidance = conflictReward;

                // 4. åè°ƒå¥–åŠ±
                const coordReward = this.calculateCoordinationReward(coordinationScore, systemStats);
                totalReward += this.weights.coordination * coordReward;
                rewardBreakdown.coordination = coordReward;

                // 5. ç­‰å¾…æ—¶é—´æƒ©ç½š
                const waitPenalty = this.calculateWaitTimePenalty(vehicle);
                totalReward += this.weights.waitTimePenalty * waitPenalty;
                rewardBreakdown.waitPenalty = waitPenalty;

                // 6. ç³»ç»Ÿååé‡å¥–åŠ±
                const throughputReward = this.calculateThroughputReward(systemStats);
                totalReward += this.weights.systemThroughput * throughputReward;
                rewardBreakdown.throughput = throughputReward;

                return {
                    total: Math.max(-5.0, Math.min(totalReward, 10.0)),
                    breakdown: rewardBreakdown,
                    explanation: this.generateRewardExplanation(rewardBreakdown)
                };
            }

            calculateTaskCompletionReward(vehicle, currentTime) {
                let reward = 0;
                
                switch (vehicle.state) {
                    case 'MOVING':
                        reward += 0.1;
                        break;
                    case 'LOADING':
                        reward += 0.5;
                        break;
                    case 'UNLOADING':
                        reward += 0.8;
                        break;
                    case 'IDLE':
                        reward += 0.05;
                        break;
                }

                if (vehicle.completedCycles > 0) {
                    const cycleBonus = Math.min(vehicle.completedCycles * 1.0, 5.0);
                    reward += cycleBonus;
                }

                const progressReward = this.calculateTaskProgressReward(vehicle);
                reward += progressReward;

                return reward;
            }

            calculateEfficiencyReward(vehicle, currentTime) {
                let reward = 0;
                
                if (vehicle.completedCycles > 0) {
                    const avgCycleTime = currentTime / vehicle.completedCycles;
                    const efficiency = Math.max(0, 1.0 - (avgCycleTime / this.benchmarks.optimalCycleTime));
                    reward += efficiency * 0.8;
                }

                if (vehicle.path && vehicle.path.length > 1 && vehicle.targetNodeId) {
                    const shortestPath = vehicle.roadNetwork.findPath(vehicle.currentNode, vehicle.targetNodeId);
                    if (shortestPath.length > 0) {
                        const pathEfficiency = Math.min(shortestPath.length / vehicle.path.length, 1.0);
                        reward += pathEfficiency * 0.3;
                    }
                }

                if (vehicle.state === 'MOVING') {
                    const speedFactor = Math.min(vehicle.speed / 1.0, 1.0);
                    reward += speedFactor * 0.2;
                }

                return reward;
            }

            calculateConflictAvoidanceReward(vehicle, conflictAvoided) {
                let reward = 0;

                if (conflictAvoided) {
                    reward += 1.5;
                }

                const preventiveAvoidance = this.checkPreventiveConflictAvoidance(vehicle);
                reward += preventiveAvoidance * 0.8;

                const criticalNodeAvoidance = this.checkCriticalNodeConflictAvoidance(vehicle);
                reward += criticalNodeAvoidance * 1.0;

                return reward;
            }

            calculateCoordinationReward(coordinationScore, systemStats) {
                let reward = 0;

                reward += coordinationScore * 0.6;

                if (systemStats) {
                    const loadBalance = this.calculateLoadBalanceScore(systemStats);
                    reward += loadBalance * 0.3;

                    const flowOptimization = this.calculateFlowOptimizationScore(systemStats);
                    reward += flowOptimization * 0.4;
                }

                return reward;
            }

            calculateWaitTimePenalty(vehicle) {
                let penalty = 0;

                if (vehicle.state === 'WAITING') {
                    const waitRatio = Math.min(vehicle.waitTime / this.benchmarks.maxWaitTime, 2.0);
                    penalty = waitRatio;
                }

                if (vehicle.state === 'PLANNING' || vehicle.retryCount > 0) {
                    penalty += Math.min(vehicle.retryCount * 0.3, 1.0);
                }

                return penalty;
            }

            calculateThroughputReward(systemStats) {
                if (!systemStats) return 0;

                let reward = 0;
                
                const completionRate = systemStats.tasksCompleted / Math.max(systemStats.totalTime, 1);
                if (completionRate > this.benchmarks.minThroughput) {
                    reward += Math.min(completionRate * 2.0, 1.0);
                }

                if (systemStats.totalWaitTime > 0) {
                    const systemEfficiency = systemStats.tasksCompleted / (systemStats.totalWaitTime + 1);
                    reward += Math.min(systemEfficiency * 0.5, 0.8);
                }

                return reward;
            }

            calculateTaskProgressReward(vehicle) {
                switch (vehicle.mode) {
                    case 'EMPTY': return 0.2;
                    case 'LOADED': return 0.4;
                    case 'RETURNING': return 0.3;
                    default: return 0.1;
                }
            }

            checkPreventiveConflictAvoidance(vehicle) {
                if (!vehicle.path || vehicle.path.length < 2) return 0;

                let avoidanceScore = 0;
                const currentTime = vehicle.roadNetwork.globalTime;

                for (let i = 0; i < vehicle.path.length - 1; i++) {
                    const from = vehicle.path[i];
                    const to = vehicle.path[i + 1];
                    const edgeKey = [from, to].sort().join('-');
                    
                    const reservations = vehicle.roadNetwork.edgeReservations.get(edgeKey) || [];
                    const futureConflicts = reservations.filter(r => 
                        r.vehicleId !== vehicle.id && 
                        r.startTime <= currentTime + 10.0 && 
                        r.endTime >= currentTime
                    );
                    
                    if (futureConflicts.length === 0) {
                        avoidanceScore += 0.1;
                    }
                }

                return Math.min(avoidanceScore, 1.0);
            }

            checkCriticalNodeConflictAvoidance(vehicle) {
                const targetPoint = vehicle.targetPointId;
                if (!targetPoint) return 0;

                const isLoadingPoint = targetPoint.startsWith('L');
                const isUnloadingPoint = targetPoint.startsWith('U');
                
                if (isLoadingPoint || isUnloadingPoint) {
                    return 0.5;
                }

                return 0;
            }

            calculateLoadBalanceScore(systemStats) {
                return Math.random() * 0.5;
            }

            calculateFlowOptimizationScore(systemStats) {
                return Math.random() * 0.3;
            }

            generateRewardExplanation(breakdown) {
                return `Task: ${breakdown.taskCompletion?.toFixed(2) || 0}, ` +
                       `Eff: ${breakdown.efficiency?.toFixed(2) || 0}, ` +
                       `Conf: ${breakdown.conflictAvoidance?.toFixed(2) || 0}, ` +
                       `Coord: ${breakdown.coordination?.toFixed(2) || 0}, ` +
                       `Wait: ${breakdown.waitPenalty?.toFixed(2) || 0}, ` +
                       `Tput: ${breakdown.throughput?.toFixed(2) || 0}`;
            }
        }

        // ============================================================================
        // æ ¸å¿ƒç±»å®šä¹‰ (ä¿ç•™åŸæœ‰ä»£ç )
        // ============================================================================

        class VehicleState {
            static IDLE = 'idle';
            static PLANNING = 'planning';
            static WAITING = 'waiting';
            static CONFIRMED = 'confirmed';
            static MOVING = 'moving';
            static LOADING = 'loading';
            static UNLOADING = 'unloading';
            static BLOCKED = 'blocked';
        }

        class VehicleMode {
            static PARKED = 'parked';
            static EMPTY = 'empty';
            static LOADED = 'loaded';
            static RETURNING = 'returning';
        }

        class SpecialPoint {
            constructor(nodeId, pointType, position = [0, 0]) {
                this.nodeId = nodeId;
                this.pointType = pointType;
                this.isOccupied = false;
                this.reservedBy = null;
                this.position = position;
                this.lastUsedTime = 0;
                this.reservedAt = 0;
            }
        }

        // ============================================================================
        // æ™ºèƒ½é“è·¯ç½‘ç»œ (ä¿ç•™åŸæœ‰ä»£ç ï¼Œå¢åŠ éœ²å¤©çŸ¿ç‰¹åŒ–åŠŸèƒ½)
        // ============================================================================

        class RoadNetwork {
            constructor() {
                this.graph = new Map();
                this.nodePositions = new Map();
                this.nodeFeatures = new Map();
                this.specialPoints = {
                    loading: new Map(),
                    unloading: new Map(),
                    parking: new Map()
                };
                
                this.edgeReservations = new Map();
                this.nodeReservations = new Map();
                this.nodeOccupancy = new Map();
                this.globalTime = 0;
                
                this.EDGE_SAFETY_BUFFER = 0.15;
                this.NODE_SAFETY_BUFFER = 0.3;
                this.PRECISION_BUFFER = 0.01;
                this.NODE_COOLING_TIME = 0.3;
                
                this.vehicles = [];
                
                this.coordinationStats = {
                    conflictsAvoided: 0,
                    reservationsMade: 0,
                    tasksCompleted: 0,
                    totalWaitTime: 0
                };
                
                // éœ²å¤©çŸ¿ç‰¹åŒ–ç»Ÿè®¡
                this.miningStats = {
                    transportEfficiency: 0,
                    avgCycleTime: 0,
                    loadingUtilization: 0,
                    unloadingUtilization: 0,
                    pathOptimization: 0
                };
                
                this.createFallbackTopology();
                this.initializeNodeFeatures();
            }

            initializeNodeFeatures() {
                for (const nodeId of this.graph.keys()) {
                    this.nodeFeatures.set(nodeId, {
                        occupancy: 0.0,
                        connectivity: 0.0,
                        congestion: 0.0,
                        centrality: 0.0,
                        reservationDensity: 0.0,
                        // éœ²å¤©çŸ¿æ–°å¢ç‰¹å¾
                        nodeType: 0.0,
                        loadingCapacity: 0.0,
                        conflictPressure: 0.0
                    });
                    this.updateNodeFeature(nodeId);
                }
            }

            updateNodeFeature(nodeId) {
                const neighbors = Array.from(this.graph.get(nodeId) || []);
                const connectivity = neighbors.length;
                
                let congestion = 0.0;
                let reservationDensity = 0.0;
                const currentTime = this.globalTime;
                
                for (const neighbor of neighbors) {
                    const edgeKey = [nodeId, neighbor].sort().join('-');
                    const reservations = this.edgeReservations.get(edgeKey) || [];
                    const futureOccupied = reservations.some(r => 
                        r.startTime <= currentTime + 2.0 && r.endTime >= currentTime
                    );
                    if (futureOccupied) congestion += 1;
                    reservationDensity += reservations.length;
                }
                
                congestion = neighbors.length > 0 ? congestion / neighbors.length : 0;
                reservationDensity = neighbors.length > 0 ? reservationDensity / neighbors.length : 0;
                
                const centrality = connectivity / 8.0;
                const occupiedVehicles = this.nodeOccupancy.get(nodeId) || new Set();
                const occupancy = occupiedVehicles.size * 0.5;
                
                const feature = this.nodeFeatures.get(nodeId);
                feature.occupancy = occupancy;
                feature.connectivity = connectivity;
                feature.congestion = congestion;
                feature.centrality = centrality;
                feature.reservationDensity = reservationDensity;
                
                // éœ²å¤©çŸ¿ç‰¹åŒ–ç‰¹å¾
                feature.nodeType = this.getNodeTypeEncoding(nodeId);
                feature.loadingCapacity = this.getLoadingCapacity(nodeId);
                feature.conflictPressure = this.calculateConflictPressure(nodeId);
            }

            getNodeTypeEncoding(nodeId) {
                for (const [type, points] of Object.entries(this.specialPoints)) {
                    for (const [pointId, point] of points) {
                        if (point.nodeId === nodeId) {
                            switch (type) {
                                case 'loading': return 0.33;
                                case 'unloading': return 0.66;
                                case 'parking': return 1.0;
                            }
                        }
                    }
                }
                return 0;
            }

            getLoadingCapacity(nodeId) {
                const nodeType = this.getNodeTypeEncoding(nodeId);
                if (nodeType === 0.33) return 1.0;
                if (nodeType === 0.66) return 0.8;
                return 0.1;
            }

            calculateConflictPressure(nodeId) {
                const neighbors = Array.from(this.graph.get(nodeId) || []);
                let conflictPressure = 0;
                
                for (const neighbor of neighbors) {
                    const occupiedVehicles = this.nodeOccupancy.get(neighbor) || new Set();
                    conflictPressure += occupiedVehicles.size * 0.25;
                }
                
                return Math.min(conflictPressure, 1.0);
            }

            // ä¿ç•™åŸæœ‰çš„createFallbackTopologyæ–¹æ³•
            createFallbackTopology() {
                const gridSize = 5;
                const nodeSpacing = 80;
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const nodeId = `N${i}_${j}`;
                        const x = 50 + j * nodeSpacing + (Math.random() - 0.5) * 20;
                        const y = 50 + i * nodeSpacing + (Math.random() - 0.5) * 20;
                        
                        this.nodePositions.set(nodeId, [x, y]);
                        this.graph.set(nodeId, new Set());
                        this.nodeOccupancy.set(nodeId, new Set());
                    }
                }

                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const currentNode = `N${i}_${j}`;
                        
                        if (j < gridSize - 1) {
                            const rightNode = `N${i}_${j + 1}`;
                            this.graph.get(currentNode).add(rightNode);
                            this.graph.get(rightNode).add(currentNode);
                        }
                        
                        if (i < gridSize - 1) {
                            const downNode = `N${i + 1}_${j}`;
                            this.graph.get(currentNode).add(downNode);
                            this.graph.get(downNode).add(currentNode);
                        }
                        
                        if (i < gridSize - 1 && j < gridSize - 1 && Math.random() > 0.5) {
                            const diagNode = `N${i + 1}_${j + 1}`;
                            this.graph.get(currentNode).add(diagNode);
                            this.graph.get(diagNode).add(currentNode);
                        }
                    }
                }

                const specialIndices = {
                    loading: [[0, 0], [0, 2], [0, 4], [2, 0], [4, 0], [4, 2]],
                    unloading: [[4, 4], [2, 4], [0, 4], [4, 2], [4, 0], [2, 4]],
                    parking: [[2, 2], [1, 1], [3, 3], [1, 3], [3, 1], [2, 0]]
                };
                
                for (let i = 0; i < 6; i++) {
                    const [row, col] = specialIndices.loading[i % specialIndices.loading.length];
                    const nodeId = `N${row}_${col}`;
                    const pointId = `L${i}`;
                    const pos = this.nodePositions.get(nodeId);
                    this.specialPoints.loading.set(pointId, new SpecialPoint(nodeId, 'loading', pos));
                }

                for (let i = 0; i < 6; i++) {
                    const [row, col] = specialIndices.unloading[i % specialIndices.unloading.length];
                    const nodeId = `N${row}_${col}`;
                    const pointId = `U${i}`;
                    const pos = this.nodePositions.get(nodeId);
                    this.specialPoints.unloading.set(pointId, new SpecialPoint(nodeId, 'unloading', pos));
                }

                for (let i = 0; i < 6; i++) {
                    const [row, col] = specialIndices.parking[i % specialIndices.parking.length];
                    const nodeId = `N${row}_${col}`;
                    const pointId = `P${i}`;
                    const pos = this.nodePositions.get(nodeId);
                    this.specialPoints.parking.set(pointId, new SpecialPoint(nodeId, 'parking', pos));
                }
            }

            // æ›´æ–°éœ²å¤©çŸ¿ç»Ÿè®¡
            updateMiningStats() {
                if (this.vehicles.length === 0) return;

                // è®¡ç®—è¿è¾“æ•ˆç‡
                const activeCycles = this.vehicles.reduce((sum, v) => sum + v.completedCycles, 0);
                const totalTime = this.globalTime;
                this.miningStats.transportEfficiency = totalTime > 0 ? (activeCycles / totalTime) * 100 : 0;

                // è®¡ç®—å¹³å‡å‘¨æœŸæ—¶é—´
                if (activeCycles > 0) {
                    this.miningStats.avgCycleTime = totalTime / activeCycles;
                }

                // è®¡ç®—è£…è½½ç‚¹åˆ©ç”¨ç‡
                let loadingOccupied = 0;
                for (const [pointId, point] of this.specialPoints.loading) {
                    if (point.isOccupied) loadingOccupied++;
                }
                this.miningStats.loadingUtilization = (loadingOccupied / this.specialPoints.loading.size) * 100;

                // è®¡ç®—å¸è½½ç‚¹åˆ©ç”¨ç‡
                let unloadingOccupied = 0;
                for (const [pointId, point] of this.specialPoints.unloading) {
                    if (point.isOccupied) unloadingOccupied++;
                }
                this.miningStats.unloadingUtilization = (unloadingOccupied / this.specialPoints.unloading.size) * 100;

                // è®¡ç®—è·¯å¾„ä¼˜åŒ–å¾—åˆ†
                const totalPathOptimization = this.vehicles.reduce((sum, v) => {
                    if (v.path && v.targetNodeId) {
                        const shortestPath = this.findPath(v.currentNode, v.targetNodeId);
                        if (shortestPath.length > 0) {
                            return sum + (shortestPath.length / v.path.length);
                        }
                    }
                    return sum;
                }, 0);
                this.miningStats.pathOptimization = (totalPathOptimization / this.vehicles.length) * 100;
            }

            // ä¿ç•™åŸæœ‰çš„å…¶ä»–æ–¹æ³•...ï¼ˆè¿™é‡Œçœç•¥ä»¥èŠ‚çœç©ºé—´ï¼Œä½†åœ¨å®é™…ä»£ç ä¸­åº”è¯¥åŒ…å«ï¼‰
            isPointTrulyAvailable(pointId, requestingVehicleId, currentTime = null) {
                if (currentTime === null) currentTime = this.globalTime;
                
                for (const [type, points] of Object.entries(this.specialPoints)) {
                    if (points.has(pointId)) {
                        const point = points.get(pointId);
                        
                        if (point.isOccupied) return false;
                        if (point.reservedBy !== null && point.reservedBy !== requestingVehicleId) return false;
                        
                        const otherVehiclesTargeting = this.vehicles.filter(v => 
                            v.id !== requestingVehicleId && 
                            (v.targetLoadingPoint === pointId || 
                             v.targetUnloadingPoint === pointId || 
                             v.targetParkingPoint === pointId)
                        );
                        
                        if (otherVehiclesTargeting.length > 0) return false;
                        
                        return true;
                    }
                }
                return false;
            }

            getAvailablePoint(pointType, excludeVehicle = -1, preferredCriteria = 'closest') {
                const points = this.specialPoints[pointType];
                const availablePoints = [];
                
                for (const [pointId, point] of points) {
                    if (this.isPointTrulyAvailable(pointId, excludeVehicle)) {
                        availablePoints.push({
                            id: pointId,
                            point: point,
                            lastUsed: point.lastUsedTime,
                            nodeId: point.nodeId
                        });
                    }
                }
                
                if (availablePoints.length === 0) return null;
                
                switch (preferredCriteria) {
                    case 'closest':
                        if (excludeVehicle >= 0 && this.vehicles[excludeVehicle]) {
                            const vehicle = this.vehicles[excludeVehicle];
                            const vehiclePos = this.nodePositions.get(vehicle.currentNode);
                            
                            if (vehiclePos) {
                                availablePoints.forEach(ap => {
                                    const pointPos = this.nodePositions.get(ap.nodeId);
                                    if (pointPos) {
                                        const dx = vehiclePos[0] - pointPos[0];
                                        const dy = vehiclePos[1] - pointPos[1];
                                        ap.distance = Math.sqrt(dx * dx + dy * dy);
                                    } else {
                                        ap.distance = Infinity;
                                    }
                                });
                                
                                availablePoints.sort((a, b) => a.distance - b.distance);
                                return availablePoints[0].id;
                            }
                        }
                        
                    case 'least_recently_used':
                    default:
                        availablePoints.sort((a, b) => a.lastUsed - b.lastUsed);
                        return availablePoints[0].id;
                }
            }

            reserveSpecialPoint(pointId, vehicleId) {
                if (!this.isPointTrulyAvailable(pointId, vehicleId)) return false;
                
                for (const [type, points] of Object.entries(this.specialPoints)) {
                    if (points.has(pointId)) {
                        const point = points.get(pointId);
                        point.reservedBy = vehicleId;
                        point.reservedAt = this.globalTime;
                        this.coordinationStats.reservationsMade++;
                        return true;
                    }
                }
                return false;
            }

            occupySpecialPoint(pointId, vehicleId) {
                for (const [type, points] of Object.entries(this.specialPoints)) {
                    if (points.has(pointId)) {
                        const point = points.get(pointId);
                        point.isOccupied = true;
                        point.reservedBy = vehicleId;
                        point.lastUsedTime = this.globalTime;
                        return;
                    }
                }
            }

            releaseSpecialPoint(pointId) {
                for (const [type, points] of Object.entries(this.specialPoints)) {
                    if (points.has(pointId)) {
                        const point = points.get(pointId);
                        point.isOccupied = false;
                        point.reservedBy = null;
                        return;
                    }
                }
            }

            isEdgeAvailable(from, to, startTime, duration, excludeVehicle = -1) {
                const edgeKey = [from, to].sort().join('-');
                const endTime = startTime + duration;
                const reservations = this.edgeReservations.get(edgeKey) || [];
                
                for (const reservation of reservations) {
                    if (reservation.vehicleId === excludeVehicle) continue;
                    
                    if (!(endTime + this.EDGE_SAFETY_BUFFER <= reservation.startTime || 
                          startTime >= reservation.endTime + this.EDGE_SAFETY_BUFFER)) {
                        return false;
                    }
                }
                
                return true;
            }

            reserveEdge(from, to, vehicleId, startTime, duration) {
                const edgeKey = [from, to].sort().join('-');
                if (!this.edgeReservations.has(edgeKey)) {
                    this.edgeReservations.set(edgeKey, []);
                }
                
                const endTime = startTime + duration;
                
                if (!this.isEdgeAvailable(from, to, startTime, duration, vehicleId)) {
                    return false;
                }
                
                const reservation = {
                    vehicleId: vehicleId,
                    startTime: startTime,
                    endTime: endTime,
                    direction: [from, to]
                };
                
                this.edgeReservations.get(edgeKey).push(reservation);
                this.coordinationStats.reservationsMade++;
                return true;
            }

            findPath(start, end) {
                if (start === end) return [start];
                
                const queue = [[start, [start]]];
                const visited = new Set([start]);
                
                while (queue.length > 0) {
                    const [current, path] = queue.shift();
                    
                    if (!this.graph.has(current)) continue;
                    
                    for (const neighbor of this.graph.get(current)) {
                        if (neighbor === end) {
                            return [...path, neighbor];
                        }
                        
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push([neighbor, [...path, neighbor]]);
                        }
                    }
                }
                
                return [];
            }

            getPointNodeId(pointId) {
                for (const [type, points] of Object.entries(this.specialPoints)) {
                    if (points.has(pointId)) {
                        return points.get(pointId).nodeId;
                    }
                }
                return null;
            }

            addVehicleToNode(vehicleId, nodeId) {
                if (!this.nodeOccupancy.has(nodeId)) {
                    this.nodeOccupancy.set(nodeId, new Set());
                }
                this.nodeOccupancy.get(nodeId).add(vehicleId);
            }

            removeVehicleFromNode(vehicleId, nodeId) {
                if (this.nodeOccupancy.has(nodeId)) {
                    this.nodeOccupancy.get(nodeId).delete(vehicleId);
                }
            }

            updateTime(currentTime) {
                this.globalTime = currentTime;
                
                // æ›´æ–°éœ²å¤©çŸ¿ç»Ÿè®¡
                this.updateMiningStats();
                
                for (const [edgeKey, reservations] of this.edgeReservations) {
                    const active = reservations.filter(r => r.endTime > currentTime);
                    if (active.length > 0) {
                        this.edgeReservations.set(edgeKey, active);
                    } else {
                        this.edgeReservations.delete(edgeKey);
                    }
                }
                
                if (Math.floor(currentTime) % 10 === 0) {
                    this.cleanupExpiredReservations(currentTime);
                }
            }

            cleanupExpiredReservations(currentTime) {
                const RESERVATION_TIMEOUT = 30.0;
                let cleanedCount = 0;
                
                for (const [type, points] of Object.entries(this.specialPoints)) {
                    for (const [pointId, point] of points) {
                        if (point.reservedBy !== null && 
                            !point.isOccupied && 
                            point.reservedAt > 0 && 
                            currentTime - point.reservedAt > RESERVATION_TIMEOUT) {
                            
                            point.reservedBy = null;
                            point.reservedAt = 0;
                            cleanedCount++;
                        }
                    }
                }
                
                if (cleanedCount > 0) {
                    console.log(`Cleaned up ${cleanedCount} expired point reservations`);
                }
            }
        }

        // ============================================================================
        // æ™ºèƒ½è½¦è¾† (ä¿ç•™åŸæœ‰ä»£ç )
        // ============================================================================

        class Vehicle {
            constructor(id, startParkingPoint, roadNetwork, useAI = true) {
                this.id = id;
                this.roadNetwork = roadNetwork;
                this.useAI = useAI;
                
                this.mode = VehicleMode.PARKED;
                this.currentParkingPoint = startParkingPoint;
                this.targetLoadingPoint = null;
                this.targetUnloadingPoint = null;
                this.targetParkingPoint = null;
                
                const startNodeId = this.roadNetwork.getPointNodeId(startParkingPoint);
                this.currentNode = startNodeId || 'N2_2';
                
                const nodePosition = this.roadNetwork.nodePositions.get(this.currentNode);
                this.position = nodePosition ? [...nodePosition] : [200, 200];
                this.targetPosition = [...this.position];
                this.previousPosition = [...this.position];
                
                this.path = [];
                this.pathIndex = 0;
                this.pathConfirmed = false;
                
                this.progress = 0;
                this.speed = 0.6 + Math.random() * 0.4;
                this.moveStartTime = 0;
                this.moveDuration = 0;
                
                this.heading = 0;
                this.lastHeading = 0;
                
                this.state = VehicleState.IDLE;
                this.waitUntil = 0;
                this.retryCount = 0;
                this.maxRetries = 3;
                this.operationStartTime = 0;
                
                this.loadingTime = 2.0;
                this.unloadingTime = 1.5;
                
                this.completedCycles = 0;
                this.totalDistance = 0;
                this.waitTime = 0;
                this.conflictsAvoided = 0;
                
                this.colors = ['#ff4444', '#4444ff', '#44ff44', '#ffaa00', '#aa44ff', '#44aaff'];
                this.color = this.colors[id % this.colors.length];
                
                this.lastDecision = null;
                this.decisionSource = 'traditional';
                this.aiConfidence = 0;
                this.coordinationScore = 0;
                
                this.roadNetwork.addVehicleToNode(this.id, this.currentNode);
                if (startParkingPoint) {
                    this.roadNetwork.occupySpecialPoint(startParkingPoint, this.id);
                }
            }

            update(currentTime, dt) {
                if (this.state !== VehicleState.MOVING && this.targetNodeId) {
                    const targetPos = this.roadNetwork.nodePositions.get(this.targetNodeId);
                    const currentPos = this.roadNetwork.nodePositions.get(this.currentNode);
                    if (targetPos && currentPos) {
                        const dx = targetPos[0] - currentPos[0];
                        const dy = targetPos[1] - currentPos[1];
                        if (dx !== 0 || dy !== 0) {
                            this.heading = Math.atan2(dy, dx);
                        }
                    }
                }
                
                switch (this.state) {
                    case VehicleState.IDLE:
                        this.planNextTask(currentTime);
                        break;
                    case VehicleState.PLANNING:
                        this.executePlanning(currentTime);
                        break;
                    case VehicleState.WAITING:
                        if (currentTime >= this.waitUntil) {
                            this.state = VehicleState.IDLE;
                            this.retryCount++;
                            if (this.retryCount > this.maxRetries) {
                                this.resetCurrentTask();
                                this.retryCount = 0;
                            }
                        } else {
                            this.waitTime += dt;
                            this.roadNetwork.coordinationStats.totalWaitTime += dt;
                        }
                        break;
                    case VehicleState.CONFIRMED:
                        this.startNextMove(currentTime);
                        break;
                    case VehicleState.MOVING:
                        this.updateMovement(currentTime, dt);
                        break;
                    case VehicleState.LOADING:
                        this.updateLoading(currentTime);
                        break;
                    case VehicleState.UNLOADING:
                        this.updateUnloading(currentTime);
                        break;
                    case VehicleState.BLOCKED:
                        this.state = VehicleState.IDLE;
                        this.retryCount++;
                        break;
                }
            }

            get targetPointId() {
                switch (this.mode) {
                    case VehicleMode.PARKED:
                    case VehicleMode.EMPTY:
                        return this.targetLoadingPoint;
                    case VehicleMode.LOADED:
                        return this.targetUnloadingPoint;
                    case VehicleMode.RETURNING:
                        return this.targetParkingPoint;
                    default:
                        return null;
                }
            }

            get targetNodeId() {
                const targetPoint = this.targetPointId;
                return targetPoint ? this.roadNetwork.getPointNodeId(targetPoint) : null;
            }

            planNextTask(currentTime) {
                switch (this.mode) {
                    case VehicleMode.PARKED:
                        const availableLoading = this.roadNetwork.getAvailablePoint('loading', this.id, 'closest');
                        if (availableLoading && this.roadNetwork.reserveSpecialPoint(availableLoading, this.id)) {
                            if (this.currentParkingPoint) {
                                this.roadNetwork.releaseSpecialPoint(this.currentParkingPoint);
                                this.currentParkingPoint = null;
                            }
                            this.targetLoadingPoint = availableLoading;
                            this.mode = VehicleMode.EMPTY;
                            this.planPathToTarget(currentTime);
                        } else {
                            this.waitAndRetry(currentTime);
                        }
                        break;
                        
                    case VehicleMode.EMPTY:
                        if (this.targetLoadingPoint) {
                            this.planPathToTarget(currentTime);
                        } else {
                            this.mode = VehicleMode.PARKED;
                            this.state = VehicleState.IDLE;
                        }
                        break;
                        
                    case VehicleMode.LOADED:
                        const availableUnloading = this.roadNetwork.getAvailablePoint('unloading', this.id, 'closest');
                        if (availableUnloading && this.roadNetwork.reserveSpecialPoint(availableUnloading, this.id)) {
                            this.targetUnloadingPoint = availableUnloading;
                            this.planPathToTarget(currentTime);
                        } else {
                            this.waitAndRetry(currentTime);
                        }
                        break;
                        
                    case VehicleMode.RETURNING:
                        const availableParking = this.roadNetwork.getAvailablePoint('parking', this.id, 'least_recently_used');
                        if (availableParking && this.roadNetwork.reserveSpecialPoint(availableParking, this.id)) {
                            this.targetParkingPoint = availableParking;
                            this.planPathToTarget(currentTime);
                        } else {
                            this.waitAndRetry(currentTime);
                        }
                        break;
                }
            }

            planPathToTarget(currentTime) {
                const targetNode = this.targetNodeId;
                if (!targetNode) {
                    this.waitAndRetry(currentTime);
                    return;
                }

                this.state = VehicleState.PLANNING;
                
                if (window.magecSystem && window.magecSystem.isEnabled && 
                    (window.magecSystem.isReady || window.magecSystem.isWarmingUp || window.magecSystem.isTraining)) {
                    this.makeMAGECDecision(currentTime);
                } else {
                    this.path = this.roadNetwork.findPath(this.currentNode, targetNode);
                    this.state = VehicleState.CONFIRMED;
                    this.decisionSource = 'traditional';
                }
            }

            executePlanning(currentTime) {
                if (!this.path || this.path.length < 2) {
                    this.waitAndRetry(currentTime);
                    return;
                }

                this.pathConfirmed = true;
                this.pathIndex = 0;
                this.state = VehicleState.CONFIRMED;
            }

            startNextMove(currentTime) {
                if (this.pathIndex + 1 >= this.path.length) {
                    this.state = VehicleState.IDLE;
                    return;
                }
                
                const nextNode = this.path[this.pathIndex + 1];
                this.targetPosition = [...this.roadNetwork.nodePositions.get(nextNode)];
                
                this.moveStartTime = currentTime;
                this.moveDuration = 1.0 / this.speed;
                
                this.progress = 0;
                this.state = VehicleState.MOVING;
            }

            updateMovement(currentTime, dt) {
                const elapsed = currentTime - this.moveStartTime;
                this.progress = Math.min(elapsed / this.moveDuration, 1.0);

                if (this.progress > 0) {
                    const startPos = this.roadNetwork.nodePositions.get(this.path[this.pathIndex]);
                    const smoothProgress = this.smoothStep(this.progress);
                    
                    this.previousPosition = [...this.position];
                    
                    this.position[0] = startPos[0] + (this.targetPosition[0] - startPos[0]) * smoothProgress;
                    this.position[1] = startPos[1] + (this.targetPosition[1] - startPos[1]) * smoothProgress;
                    
                    const dx = this.targetPosition[0] - startPos[0];
                    const dy = this.targetPosition[1] - startPos[1];
                    if (dx !== 0 || dy !== 0) {
                        this.heading = Math.atan2(dy, dx);
                    }
                    
                    if (dt > 0) {
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        this.totalDistance += distance * (this.progress / (elapsed / dt)) * dt * 0.01;
                    }
                }

                if (this.progress >= 1.0) {
                    this.arriveAtNode(currentTime);
                }
            }

            smoothStep(t) {
                return t * t * (3.0 - 2.0 * t);
            }

            arriveAtNode(currentTime) {
                this.roadNetwork.removeVehicleFromNode(this.id, this.currentNode);
                
                this.pathIndex++;
                this.currentNode = this.path[this.pathIndex];
                this.position = [...this.targetPosition];
                
                this.roadNetwork.addVehicleToNode(this.id, this.currentNode);
                this.retryCount = 0;
                
                if (this.pathIndex + 1 >= this.path.length) {
                    const targetPoint = this.targetPointId;
                    const targetNode = this.targetNodeId;

                    if (targetNode && this.currentNode === targetNode) {
                        if (this.mode === VehicleMode.EMPTY && targetPoint === this.targetLoadingPoint) {
                            this.startLoading(currentTime);
                        } else if (this.mode === VehicleMode.LOADED && targetPoint === this.targetUnloadingPoint) {
                            this.startUnloading(currentTime);
                        } else if (this.mode === VehicleMode.RETURNING && targetPoint === this.targetParkingPoint) {
                            this.startParking(currentTime);
                        } else {
                            this.state = VehicleState.IDLE;
                            this.pathConfirmed = false;
                        }
                    } else {
                        this.state = VehicleState.IDLE;
                        this.pathConfirmed = false;
                    }
                } else {
                    this.startNextMove(currentTime);
                }
            }

            startLoading(currentTime) {
                this.roadNetwork.occupySpecialPoint(this.targetLoadingPoint, this.id);
                this.state = VehicleState.LOADING;
                this.operationStartTime = currentTime;
            }

            startUnloading(currentTime) {
                this.roadNetwork.occupySpecialPoint(this.targetUnloadingPoint, this.id);
                this.state = VehicleState.UNLOADING;
                this.operationStartTime = currentTime;
            }

            startParking(currentTime) {
                this.roadNetwork.occupySpecialPoint(this.targetParkingPoint, this.id);
                this.currentParkingPoint = this.targetParkingPoint;
                this.targetParkingPoint = null;
                this.mode = VehicleMode.PARKED;
                this.state = VehicleState.IDLE;
                this.completedCycles++;
                this.roadNetwork.coordinationStats.tasksCompleted++;
                this.pathConfirmed = false;
            }

            updateLoading(currentTime) {
                if (currentTime - this.operationStartTime >= this.loadingTime) {
                    this.roadNetwork.releaseSpecialPoint(this.targetLoadingPoint);
                    this.mode = VehicleMode.LOADED;
                    this.targetLoadingPoint = null;
                    this.state = VehicleState.IDLE;
                    this.pathConfirmed = false;
                }
            }

            updateUnloading(currentTime) {
                if (currentTime - this.operationStartTime >= this.unloadingTime) {
                    this.roadNetwork.releaseSpecialPoint(this.targetUnloadingPoint);
                    this.mode = VehicleMode.RETURNING;
                    this.targetUnloadingPoint = null;
                    this.state = VehicleState.IDLE;
                    this.pathConfirmed = false;
                }
            }

            waitAndRetry(currentTime) {
                this.waitUntil = currentTime + 1.0 + Math.random();
                this.state = VehicleState.WAITING;
            }

            resetCurrentTask() {
                this.targetLoadingPoint = null;
                this.targetUnloadingPoint = null;
                this.targetParkingPoint = null;
                this.retryCount = 0;
                
                if (this.mode !== VehicleMode.PARKED) {
                    this.mode = VehicleMode.RETURNING;
                }
            }

            async makeMAGECDecision(currentTime) {
                if (!window.magecSystem) {
                    this.path = this.roadNetwork.findPath(this.currentNode, this.targetNodeId);
                    this.state = VehicleState.CONFIRMED;
                    this.decisionSource = 'traditional';
                    return;
                }

                try {
                    const decision = await window.magecSystem.makeDecision(this, currentTime);
                    
                    if (decision && decision.path && decision.path.length > 1) {
                        this.path = decision.path;
                        this.aiConfidence = decision.confidence || 0;
                        this.lastDecision = decision;
                        this.decisionSource = 'magec';
                        this.state = VehicleState.CONFIRMED;
                        
                        this.coordinationScore = decision.coordinationScore || 0;
                        if (decision.conflictAvoided) {
                            this.conflictsAvoided++;
                            this.roadNetwork.coordinationStats.conflictsAvoided++;
                        }
                        
                        window.magecSystem.aiDecisionCount++;
                    } else {
                        this.path = this.roadNetwork.findPath(this.currentNode, this.targetNodeId);
                        this.state = VehicleState.CONFIRMED;
                        this.decisionSource = 'traditional';
                    }
                    
                } catch (error) {
                    console.warn('MAGEC decision failed:', error);
                    this.path = this.roadNetwork.findPath(this.currentNode, this.targetNodeId);
                    this.state = VehicleState.CONFIRMED;
                    this.decisionSource = 'traditional';
                }
            }
        }

        // ============================================================================
        // å¯è§†åŒ–ç³»ç»Ÿ (ä¿ç•™åŸæœ‰ä»£ç )
        // ============================================================================

        class Visualization {
            constructor(canvas, roadNetwork) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.roadNetwork = roadNetwork;
                this.vehicles = [];
                
                this.setupCanvas();
                this.setupTransform();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            setupTransform() {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                for (const [nodeId, pos] of this.roadNetwork.nodePositions) {
                    minX = Math.min(minX, pos[0]);
                    minY = Math.min(minY, pos[1]);
                    maxX = Math.max(maxX, pos[0]);
                    maxY = Math.max(maxY, pos[1]);
                }
                
                const margin = 50;
                const canvasWidth = this.canvas.width / window.devicePixelRatio;
                const canvasHeight = this.canvas.height / window.devicePixelRatio;
                
                const networkWidth = maxX - minX;
                const networkHeight = maxY - minY;
                
                this.scale = Math.min(
                    (canvasWidth - 2 * margin) / networkWidth,
                    (canvasHeight - 2 * margin) / networkHeight
                );
                
                this.offsetX = margin - minX * this.scale + (canvasWidth - networkWidth * this.scale) / 2;
                this.offsetY = margin - minY * this.scale + (canvasHeight - networkHeight * this.scale) / 2;
            }

            transformPoint(x, y) {
                return [
                    x * this.scale + this.offsetX,
                    y * this.scale + this.offsetY
                ];
            }

            draw(currentTime) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawNetwork();
                this.drawReservations(currentTime);
                this.drawSpecialPoints();
                this.drawVehicles();
            }

            drawNetwork() {
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1.5;
                
                const drawnEdges = new Set();
                
                for (const [nodeId, neighbors] of this.roadNetwork.graph) {
                    const pos1 = this.roadNetwork.nodePositions.get(nodeId);
                    const [x1, y1] = this.transformPoint(pos1[0], pos1[1]);
                    
                    for (const neighborId of neighbors) {
                        const edgeKey = [nodeId, neighborId].sort().join('-');
                        if (drawnEdges.has(edgeKey)) continue;
                        drawnEdges.add(edgeKey);
                        
                        const pos2 = this.roadNetwork.nodePositions.get(neighborId);
                        const [x2, y2] = this.transformPoint(pos2[0], pos2[1]);
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.stroke();
                    }
                }

                for (const [nodeId, pos] of this.roadNetwork.nodePositions) {
                    let isSpecial = false;
                    for (const [type, points] of Object.entries(this.roadNetwork.specialPoints)) {
                        for (const [pointId, point] of points) {
                            if (point.nodeId === nodeId) {
                                isSpecial = true;
                                break;
                            }
                        }
                        if (isSpecial) break;
                    }
                    
                    if (isSpecial) continue;

                    const [x, y] = this.transformPoint(pos[0], pos[1]);
                    const occupiedVehicles = this.roadNetwork.nodeOccupancy.get(nodeId) || new Set();
                    
                    let fillColor = '#e3f2fd';
                    let strokeColor = '#1976d2';
                    let strokeWidth = 1;
                    
                    if (occupiedVehicles.size > 0) {
                        fillColor = '#fce4ec';
                        strokeColor = '#c2185b';
                        strokeWidth = 2;
                    }
                    
                    const radius = 6;
                    
                    this.ctx.fillStyle = fillColor;
                    this.ctx.strokeStyle = strokeColor;
                    this.ctx.lineWidth = strokeWidth;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }

            drawReservations(currentTime) {
                for (const [edgeKey, reservations] of this.roadNetwork.edgeReservations) {
                    const [node1, node2] = edgeKey.split('-');
                    const pos1 = this.roadNetwork.nodePositions.get(node1);
                    const pos2 = this.roadNetwork.nodePositions.get(node2);
                    
                    if (!pos1 || !pos2) continue;
                    
                    const [x1, y1] = this.transformPoint(pos1[0], pos1[1]);
                    const [x2, y2] = this.transformPoint(pos2[0], pos2[1]);
                    
                    const activeReservations = reservations
                        .filter(r => r.endTime > currentTime)
                        .sort((a, b) => a.startTime - b.startTime);
                    
                    for (let i = 0; i < activeReservations.length; i++) {
                        const reservation = activeReservations[i];
                        const vehicle = this.vehicles.find(v => v.id === reservation.vehicleId);
                        if (!vehicle) continue;
                        
                        this.ctx.strokeStyle = vehicle.color;
                        this.ctx.lineWidth = 4;
                        this.ctx.globalAlpha = reservation.startTime <= currentTime ? 0.8 : 0.4;
                        
                        if (reservation.startTime > currentTime) {
                            this.ctx.setLineDash([5, 5]);
                        }
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.stroke();
                        
                        this.ctx.setLineDash([]);
                        this.ctx.globalAlpha = 1;
                    }
                }
            }

            drawSpecialPoints() {
                const types = [
                    { key: 'loading', symbol: 'L', color: '#4caf50', darkColor: '#2e7d32', strokeColor: '#1b5e20' },
                    { key: 'unloading', symbol: 'U', color: '#2196f3', darkColor: '#1565c0', strokeColor: '#0d47a1' },
                    { key: 'parking', symbol: 'P', color: '#9e9e9e', darkColor: '#424242', strokeColor: '#212121' }
                ];
                
                for (const typeInfo of types) {
                    const points = this.roadNetwork.specialPoints[typeInfo.key];
                    
                    for (const [pointId, point] of points) {
                        const pos = this.roadNetwork.nodePositions.get(point.nodeId);
                        if (!pos) continue;
                        
                        const [x, y] = this.transformPoint(pos[0], pos[1]);
                        
                        let fillColor;
                        if (point.isOccupied) {
                            fillColor = typeInfo.darkColor;
                        } else if (point.reservedBy !== null) {
                            fillColor = '#ff9800';
                        } else {
                            fillColor = typeInfo.color;
                        }
                        
                        this.ctx.fillStyle = fillColor;
                        this.ctx.strokeStyle = typeInfo.strokeColor;
                        this.ctx.lineWidth = 3;
                        
                        if (typeInfo.key === 'loading') {
                            const size = 14;
                            this.ctx.fillRect(x - size/2, y - size/2, size, size);
                            this.ctx.strokeRect(x - size/2, y - size/2, size, size);
                        } else if (typeInfo.key === 'unloading') {
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, y - 10);
                            this.ctx.lineTo(x - 8, y + 6);
                            this.ctx.lineTo(x + 8, y + 6);
                            this.ctx.closePath();
                            this.ctx.fill();
                            this.ctx.stroke();
                        } else {
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 10, 0, 2 * Math.PI);
                            this.ctx.fill();
                            this.ctx.stroke();
                        }
                        
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = 'bold 12px monospace';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(typeInfo.symbol, x, y);
                        
                        this.ctx.fillStyle = '#333';
                        this.ctx.font = 'bold 10px monospace';
                        this.ctx.fillText(pointId, x, y - 20);
                    }
                }
            }

            drawVehicles() {
                for (const vehicle of this.vehicles) {
                    const [x, y] = this.transformPoint(vehicle.position[0], vehicle.position[1]);
                    
                    let width = 16;
                    let height = 10;
                    
                    if (vehicle.mode === VehicleMode.LOADED) {
                        width = 20;
                        height = 12;
                    }
                    
                    let strokeColor = '#333';
                    let strokeWidth = 2;
                    let alpha = 1.0;
                    
                    if (vehicle.decisionSource === 'magec') {
                        strokeColor = '#4CAF50';
                        strokeWidth = 3;
                        const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 0.8;
                        alpha = pulse;
                    } else if (vehicle.state === VehicleState.PLANNING) {
                        strokeColor = '#FF9800';
                        strokeWidth = 3;
                    }
                    
                    this.ctx.save();
                    this.ctx.translate(x, y);
                    this.ctx.rotate(vehicle.heading);
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.fillStyle = vehicle.color;
                    this.ctx.strokeStyle = strokeColor;
                    this.ctx.lineWidth = strokeWidth;
                    
                    this.ctx.fillRect(-width/2, -height/2, width, height);
                    this.ctx.strokeRect(-width/2, -height/2, width, height);
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillRect(width/2 - 3, -height/4, 3, height/2);
                    
                    if (vehicle.mode === VehicleMode.LOADED) {
                        this.ctx.fillStyle = '#ffeb3b';
                        this.ctx.fillRect(-width/2 + 2, -height/2 + 2, width - 4, height - 4);
                    }
                    
                    if (vehicle.decisionSource === 'magec') {
                        this.ctx.rotate(-vehicle.heading);
                        this.ctx.fillStyle = '#4CAF50';
                        this.ctx.font = 'bold 8px monospace';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'top';
                        this.ctx.fillText('ğŸ§ ', 0, height/2 + 2);
                        this.ctx.rotate(vehicle.heading);
                    }
                    
                    this.ctx.rotate(-vehicle.heading);
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 10px monospace';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(vehicle.id.toString(), 0, 0);
                    
                    this.ctx.restore();
                    this.ctx.globalAlpha = 1.0;
                }
            }
        }

        // ============================================================================
        // ä¼˜åŒ–çš„MAGECç³»ç»Ÿ (é›†æˆè®ºæ–‡ç®—æ³•)
        // ============================================================================

        class OptimizedMAGECSystem {
            constructor() {
                this.isEnabled = true;
                this.isReady = false;
                this.isTraining = false;
                this.isWarmingUp = false;
                
                this.gnnModel = null;
                this.actorModel = null;
                this.criticModel = null;
                
                this.batchSizeGPU = 64;
                this.learningRate = 0.0003;
                this.epsilon = 0.1;
                this.gamma = 0.99;
                
                this.episode = 0;
                this.maxEpisodes = 2000;
                this.episodeRewards = [];
                this.avgReward = 0;
                this.aiDecisionCount = 0;
                this.totalDecisions = 0;
                
                this.experiences = [];
                this.maxExperiences = 20000;
                this.batchSize = this.batchSizeGPU;
                this.minExperiencesForTraining = this.batchSize * 2;
                
                this.coordinationMetrics = {
                    conflictRate: 0,
                    cooperationScore: 0,
                    taskCompletionRate: 0,
                    averageWaitTime: 0,
                    conflictAvoidedCount: 0,
                    totalCoordinationScore: 0,
                    coordinationDecisions: 0
                };
                
                // é›†æˆéœ²å¤©çŸ¿å¥–åŠ±ç³»ç»Ÿ
                this.rewardSystem = new MiningTransportRewardSystem();
                
                console.log(`ğŸš› éœ²å¤©çŸ¿MAGECç³»ç»Ÿåˆå§‹åŒ–: æœ€å°ç»éªŒ=${this.minExperiencesForTraining}, æ‰¹æ¬¡=${this.batchSize}`);
                
                this.initializeModels();
            }

            async initializeModels() {
                console.log('ğŸ§  åˆå§‹åŒ–éœ²å¤©çŸ¿ä¼˜åŒ–MAGECæ¨¡å‹...');
                
                try {
                    if (!gpuInitialized) {
                        console.log('â³ ç­‰å¾…GPUåˆå§‹åŒ–å®Œæˆ...');
                        await initializeGPU();
                    }
                    
                    if (typeof tf !== 'undefined') {
                        await tf.ready();
                        console.log('âœ… TensorFlow.jså°±ç»ªï¼Œåç«¯:', tf.getBackend());
                    } else {
                        throw new Error('TensorFlow.jsæœªåŠ è½½');
                    }
                    
                    await this.loadSavedModels();
                    
                    if (!this.gnnModel) {
                        await this.createOptimizedModels();
                    }
                    
                    this.isReady = true;
                    console.log('âœ… éœ²å¤©çŸ¿ä¼˜åŒ–MAGECç³»ç»Ÿå°±ç»ª');
                    this.updateUI();
                    
                } catch (error) {
                    console.error('âŒ éœ²å¤©çŸ¿MAGECåˆå§‹åŒ–å¤±è´¥:', error);
                    this.isReady = false;
                }
            }

            async loadSavedModels() {
                try {
                    this.gnnModel = await tf.loadLayersModel('localstorage://mining-magec-gnn');
                    this.actorModel = await tf.loadLayersModel('localstorage://mining-magec-actor');
                    this.criticModel = await tf.loadLayersModel('localstorage://mining-magec-critic');
                    console.log('ğŸ“¥ å·²åŠ è½½éœ²å¤©çŸ¿MAGECæ¨¡å‹');
                } catch (error) {
                    console.log('ğŸ“¦ æœªæ‰¾åˆ°ä¿å­˜çš„æ¨¡å‹ï¼Œåˆ›å»ºæ–°æ¨¡å‹...');
                }
            }

            async createOptimizedModels() {
                console.log('ğŸ—ï¸ åˆ›å»ºè®ºæ–‡ä¼˜åŒ–çš„ç¥ç»ç½‘ç»œ...');
                
                // å¢å¼ºçš„GNNæ¨¡å‹ - é›†æˆè¾¹ç‰¹å¾å¤„ç† (åŸºäºè®ºæ–‡Algorithm 1)
                this.gnnModel = tf.sequential({
                    layers: [
                        tf.layers.dense({
                            units: 128,
                            activation: 'relu',
                            inputShape: [8],
                            name: 'gnn_input_enhanced',
                            kernelRegularizer: tf.regularizers.l2({l2: 0.01})
                        }),
                        tf.layers.dropout({rate: 0.2}),
                        tf.layers.dense({
                            units: 96,
                            activation: 'relu',
                            name: 'gnn_layer_2'
                        }),
                        tf.layers.dropout({rate: 0.15}),
                        tf.layers.dense({
                            units: 64,
                            activation: 'relu',
                            name: 'gnn_layer_3'
                        }),
                        tf.layers.dropout({rate: 0.1}),
                        tf.layers.dense({
                            units: 32,
                            activation: 'tanh',
                            name: 'graph_embedding'
                        })
                    ]
                });

                // Neighbor Scoring Actor (è®ºæ–‡Section IV-Dçš„æ ¸å¿ƒåˆ›æ–°)
                this.actorModel = tf.sequential({
                    layers: [
                        tf.layers.dense({
                            units: 128,
                            activation: 'relu',
                            inputShape: [32],
                            name: 'neighbor_scorer_1'
                        }),
                        tf.layers.dropout({rate: 0.2}),
                        tf.layers.dense({
                            units: 64,
                            activation: 'relu',
                            name: 'neighbor_scorer_2'
                        }),
                        tf.layers.dropout({rate: 0.1}),
                        tf.layers.dense({
                            units: 32,
                            activation: 'relu',
                            name: 'selector_layer'
                        }),
                        tf.layers.dense({
                            units: 8,
                            activation: 'softmax',
                            name: 'action_distribution'
                        })
                    ]
                });

                // å…¨å±€ä»·å€¼ä¼°è®¡å™¨ (è®ºæ–‡çš„Critic)
                this.criticModel = tf.sequential({
                    layers: [
                        tf.layers.dense({
                            units: 256,
                            activation: 'relu',
                            inputShape: [32],
                            name: 'critic_global_1'
                        }),
                        tf.layers.dropout({rate: 0.3}),
                        tf.layers.dense({
                            units: 128,
                            activation: 'relu',
                            name: 'critic_global_2'
                        }),
                        tf.layers.dropout({rate: 0.2}),
                        tf.layers.dense({
                            units: 64,
                            activation: 'relu',
                            name: 'critic_global_3'
                        }),
                        tf.layers.dense({
                            units: 1,
                            activation: 'linear',
                            name: 'value_estimate'
                        })
                    ]
                });

                const optimizerConfig = {
                    learningRate: this.learningRate,
                    beta1: 0.9,
                    beta2: 0.999,
                    epsilon: 1e-8
                };

                this.gnnModel.compile({
                    optimizer: tf.train.adam(optimizerConfig),
                    loss: 'meanSquaredError',
                    metrics: ['accuracy']
                });

                this.actorModel.compile({
                    optimizer: tf.train.adam(optimizerConfig),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });

                this.criticModel.compile({
                    optimizer: tf.train.adam(optimizerConfig),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });

                console.log('âœ… éœ²å¤©çŸ¿ä¼˜åŒ–æ¨¡å‹åˆ›å»ºå®Œæˆ');
            }

            async makeDecision(vehicle, currentTime) {
                if (!vehicle.targetNodeId) {
                    return null;
                }

                try {
                    const features = this.extractEnhancedFeatures(vehicle);
                    if (!features) {
                        if (this.isTraining || this.isWarmingUp) {
                            this.storeBasicExperience(vehicle, currentTime);
                        }
                        return null;
                    }
                    
                    let selectedAction;
                    let confidence = 0.5;
                    
                    if (this.isReady && this.gnnModel && this.actorModel) {
                        const gnnOutput = this.gnnModel.predict(features);
                        const actionProbs = this.actorModel.predict(gnnOutput);
                        const actionProbsArray = await actionProbs.data();
                        
                        if (Math.random() < this.epsilon && this.isTraining) {
                            selectedAction = Math.floor(Math.random() * actionProbsArray.length);
                        } else {
                            selectedAction = this.argMax(actionProbsArray);
                        }
                        
                        confidence = Math.max(...actionProbsArray);
                        
                        gnnOutput.dispose();
                        actionProbs.dispose();
                    } else {
                        selectedAction = Math.floor(Math.random() * 8);
                        confidence = 0.3;
                    }
                    
                    const path = this.actionToPath(vehicle, selectedAction);
                    const conflictAvoided = this.checkAdvancedConflictAvoidance(vehicle, path);
                    const coordinationScore = this.calculateAdvancedCoordinationScore(vehicle, path);
                    
                    this.storeEnhancedExperience(vehicle, features, selectedAction, currentTime, conflictAvoided, coordinationScore);
                    
                    this.updateRealtimeMetrics(conflictAvoided, coordinationScore);
                    
                    features.dispose();
                    this.totalDecisions++;
                    this.aiDecisionCount++;
                    
                    return {
                        path: path,
                        confidence: confidence,
                        action: selectedAction,
                        source: 'magec',
                        conflictAvoided: conflictAvoided,
                        coordinationScore: coordinationScore
                    };
                    
                } catch (error) {
                    console.warn('ä¼˜åŒ–MAGECå†³ç­–é”™è¯¯:', error);
                    
                    if (this.isTraining || this.isWarmingUp) {
                        this.storeBasicExperience(vehicle, currentTime);
                    }
                    
                    return null;
                }
            }

            extractEnhancedFeatures(vehicle) {
                try {
                    const nodeFeature = vehicle.roadNetwork.nodeFeatures.get(vehicle.currentNode);
                    if (!nodeFeature) return null;
                    
                    // éœ²å¤©çŸ¿å¢å¼ºç‰¹å¾ (8ç»´)
                    const features = [
                        nodeFeature.occupancy,
                        nodeFeature.connectivity / 8.0,
                        nodeFeature.congestion,
                        nodeFeature.centrality,
                        nodeFeature.reservationDensity / 10.0,
                        nodeFeature.nodeType,        // æ–°å¢ï¼šèŠ‚ç‚¹ç±»å‹ç¼–ç 
                        nodeFeature.loadingCapacity, // æ–°å¢ï¼šè£…è½½èƒ½åŠ›
                        nodeFeature.conflictPressure // æ–°å¢ï¼šå†²çªå‹åŠ›
                    ];
                    
                    return tf.tensor2d([features]);
                    
                } catch (error) {
                    console.warn('å¢å¼ºç‰¹å¾æå–é”™è¯¯:', error);
                    return null;
                }
            }

            actionToPath(vehicle, action) {
                const neighbors = Array.from(vehicle.roadNetwork.graph.get(vehicle.currentNode) || []);
                if (neighbors.length === 0) {
                    return [vehicle.currentNode];
                }
                
                const targetNeighbor = neighbors[action % neighbors.length];
                const finalTarget = vehicle.targetNodeId;
                
                if (!finalTarget) {
                    return [vehicle.currentNode, targetNeighbor];
                }
                
                if (targetNeighbor === finalTarget) {
                    return [vehicle.currentNode, targetNeighbor];
                } else {
                    const pathToTarget = vehicle.roadNetwork.findPath(targetNeighbor, finalTarget);
                    if (pathToTarget.length > 0) {
                        return [vehicle.currentNode, ...pathToTarget];
                    } else {
                        return [vehicle.currentNode, targetNeighbor];
                    }
                }
            }

            checkAdvancedConflictAvoidance(vehicle, path) {
                if (!path || path.length < 2) return false;
                
                let conflictsAvoided = 0;
                const currentTime = vehicle.roadNetwork.globalTime;
                const PREDICTION_HORIZON = 10.0;
                
                // 1. è¾¹å†²çªæ£€æµ‹ (è®ºæ–‡æ ¸å¿ƒ)
                for (let i = 0; i < path.length - 1; i++) {
                    const from = path[i];
                    const to = path[i + 1];
                    const edgeKey = [from, to].sort().join('-');
                    
                    const reservations = vehicle.roadNetwork.edgeReservations.get(edgeKey) || [];
                    const futureConflicts = reservations.filter(r => 
                        r.vehicleId !== vehicle.id && 
                        r.startTime <= currentTime + PREDICTION_HORIZON &&
                        r.endTime >= currentTime
                    );
                    
                    if (futureConflicts.length > 0) {
                        conflictsAvoided++;
                    }
                }
                
                // 2. å…³é”®èµ„æºç‚¹å†²çªæ£€æµ‹ (éœ²å¤©çŸ¿ç‰¹åŒ–)
                const targetNode = path[path.length - 1];
                const isLoadingPoint = this.isSpecialPoint(targetNode, 'loading', vehicle.roadNetwork);
                const isUnloadingPoint = this.isSpecialPoint(targetNode, 'unloading', vehicle.roadNetwork);
                
                if ((isLoadingPoint || isUnloadingPoint)) {
                    const targetOccupancy = vehicle.roadNetwork.nodeOccupancy.get(targetNode) || new Set();
                    if (targetOccupancy.size === 0) {
                        conflictsAvoided++;
                    }
                }
                
                return conflictsAvoided > 0;
            }

            calculateAdvancedCoordinationScore(vehicle, path) {
                if (!path || path.length < 2) return Math.random() * 0.3;
                
                let score = 0;
                const allVehicles = vehicle.roadNetwork.vehicles || [];
                
                // è·¯å¾„æ‹¥å µæ£€æŸ¥
                let totalCongestion = 0;
                let pathComplexity = 0;
                for (let i = 1; i < path.length; i++) {
                    const nodeFeature = vehicle.roadNetwork.nodeFeatures.get(path[i]);
                    if (nodeFeature) {
                        totalCongestion += nodeFeature.congestion;
                        pathComplexity += nodeFeature.connectivity / 8.0;
                    }
                }
                const avgCongestion = totalCongestion / (path.length - 1);
                const avgComplexity = pathComplexity / (path.length - 1);
                
                // æ‹¥å µé¿å…å¥–åŠ±
                score += Math.max(0, 1.0 - avgCongestion) * 0.4;
                
                // è·¯å¾„å¤æ‚åº¦å¥–åŠ±
                score += Math.min(avgComplexity, 1.0) * 0.2;
                
                // ç›®æ ‡å†²çªæ£€æŸ¥
                const targetNode = path[path.length - 1];
                let conflictingVehicles = 0;
                for (const v of allVehicles) {
                    if (v.id !== vehicle.id) {
                        if (v.targetNodeId === targetNode) conflictingVehicles++;
                        if (v.path && v.path.includes(targetNode)) conflictingVehicles += 0.5;
                    }
                }
                
                // å†²çªé¿å…å¥–åŠ±
                const conflictAvoidance = Math.max(0, 1.0 - conflictingVehicles / Math.max(allVehicles.length - 1, 1));
                score += conflictAvoidance * 0.3;
                
                // è·¯å¾„æ•ˆç‡æ£€æŸ¥
                const shortestPath = vehicle.roadNetwork.findPath(vehicle.currentNode, vehicle.targetNodeId);
                if (shortestPath.length > 0) {
                    const efficiency = Math.min(shortestPath.length / path.length, 1.0);
                    score += efficiency * 0.1;
                } else {
                    score += 0.05;
                }
                
                // æ—¶é—´å› ç´ 
                let timeFactor = 1.0;
                switch (vehicle.state) {
                    case VehicleState.MOVING:
                        timeFactor = 1.2;
                        break;
                    case VehicleState.WAITING:
                        timeFactor = 0.8;
                        break;
                    case VehicleState.LOADING:
                    case VehicleState.UNLOADING:
                        timeFactor = 1.1;
                        break;
                }
                
                score *= timeFactor;
                score += (Math.random() - 0.5) * 0.1;
                
                return Math.max(0, Math.min(score, 1.0));
            }

            isSpecialPoint(nodeId, pointType, roadNetwork) {
                const points = roadNetwork.specialPoints[pointType] || new Map();
                for (const [pointId, point] of points) {
                    if (point.nodeId === nodeId) return true;
                }
                return false;
            }

            storeEnhancedExperience(vehicle, features, action, currentTime, conflictAvoided, coordinationScore) {
                // ä½¿ç”¨éœ²å¤©çŸ¿ä¸“ç”¨å¥–åŠ±ç³»ç»Ÿ
                const systemStats = {
                    tasksCompleted: vehicle.roadNetwork.coordinationStats.tasksCompleted,
                    totalWaitTime: vehicle.roadNetwork.coordinationStats.totalWaitTime,
                    totalTime: currentTime
                };
                
                const rewardResult = this.rewardSystem.calculateReward(
                    vehicle, 
                    currentTime, 
                    conflictAvoided, 
                    coordinationScore, 
                    systemStats
                );
                
                const experience = {
                    features: features,
                    action: action,
                    reward: rewardResult.total,
                    conflictAvoided: conflictAvoided,
                    coordinationScore: coordinationScore,
                    vehicleId: vehicle.id,
                    timestamp: currentTime,
                    rewardBreakdown: rewardResult.breakdown
                };
                
                this.experiences.push(experience);
                
                this.episodeRewards.push(rewardResult.total);
                if (this.episodeRewards.length > 100) {
                    this.episodeRewards.shift();
                }
                this.avgReward = this.episodeRewards.reduce((a, b) => a + b, 0) / this.episodeRewards.length;
                
                if (this.experiences.length > this.maxExperiences) {
                    const removed = this.experiences.shift();
                    if (removed.features && !removed.features.isDisposed) {
                        removed.features.dispose();
                    }
                }
            }

            storeBasicExperience(vehicle, currentTime) {
                try {
                    const basicFeatures = tf.tensor2d([[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]]);
                    const randomAction = Math.floor(Math.random() * 8);
                    
                    const mockConflictAvoided = Math.random() > 0.7;
                    const mockCoordinationScore = Math.random() * 0.8 + 0.1;
                    
                    const systemStats = {
                        tasksCompleted: vehicle.roadNetwork.coordinationStats.tasksCompleted || 0,
                        totalWaitTime: vehicle.roadNetwork.coordinationStats.totalWaitTime || 0,
                        totalTime: currentTime
                    };
                    
                    const rewardResult = this.rewardSystem.calculateReward(
                        vehicle, 
                        currentTime, 
                        mockConflictAvoided, 
                        mockCoordinationScore, 
                        systemStats
                    );
                    
                    const experience = {
                        features: basicFeatures,
                        action: randomAction,
                        reward: rewardResult.total,
                        conflictAvoided: mockConflictAvoided,
                        coordinationScore: mockCoordinationScore,
                        vehicleId: vehicle.id,
                        timestamp: currentTime
                    };
                    
                    this.experiences.push(experience);
                    
                    this.updateRealtimeMetrics(mockConflictAvoided, mockCoordinationScore);
                    
                    this.episodeRewards.push(rewardResult.total);
                    if (this.episodeRewards.length > 100) {
                        this.episodeRewards.shift();
                    }
                    this.avgReward = this.episodeRewards.reduce((a, b) => a + b, 0) / this.episodeRewards.length;
                    
                    if (this.experiences.length > this.maxExperiences) {
                        const removed = this.experiences.shift();
                        if (removed.features && !removed.features.isDisposed) {
                            removed.features.dispose();
                        }
                    }
                    
                } catch (error) {
                    console.warn('å­˜å‚¨åŸºç¡€ç»éªŒå¤±è´¥:', error);
                }
            }

            updateRealtimeMetrics(conflictAvoided, coordinationScore) {
                if (conflictAvoided) {
                    this.coordinationMetrics.conflictAvoidedCount = (this.coordinationMetrics.conflictAvoidedCount || 0) + 1;
                }
                
                this.coordinationMetrics.totalCoordinationScore = (this.coordinationMetrics.totalCoordinationScore || 0) + coordinationScore;
                this.coordinationMetrics.coordinationDecisions = (this.coordinationMetrics.coordinationDecisions || 0) + 1;
                
                if (this.coordinationMetrics.coordinationDecisions > 0) {
                    this.coordinationMetrics.cooperationScore = this.coordinationMetrics.totalCoordinationScore / this.coordinationMetrics.coordinationDecisions;
                    this.coordinationMetrics.conflictRate = Math.max(0, 1 - (this.coordinationMetrics.conflictAvoidedCount || 0) / this.coordinationMetrics.coordinationDecisions);
                }
            }

            async startTraining() {
                if (this.isTraining) return;
                
                console.log(`ğŸ”„ å¼€å§‹éœ²å¤©çŸ¿è®­ç»ƒè¿‡ç¨‹ï¼Œå½“å‰ç»éªŒæ•°æ®: ${this.experiences.length}`);
                
                if (this.experiences.length < this.minExperiencesForTraining) {
                    console.log(`ğŸ”„ å¼€å§‹é¢„çƒ­é˜¶æ®µï¼Œéœ€è¦æ”¶é›†${this.minExperiencesForTraining}æ¡ç»éªŒæ•°æ®...`);
                    this.isWarmingUp = true;
                    this.showWarmupIndicator();
                    
                    const warmupInterval = setInterval(() => {
                        const progress = (this.experiences.length / this.minExperiencesForTraining * 100).toFixed(1);
                        document.getElementById('warmup-progress').textContent = 
                            `${progress}% (${this.experiences.length}/${this.minExperiencesForTraining})`;
                        
                        console.log(`ğŸ“Š é¢„çƒ­è¿›åº¦: ${this.experiences.length}/${this.minExperiencesForTraining} (${progress}%)`);
                        
                        if (this.experiences.length >= this.minExperiencesForTraining) {
                            clearInterval(warmupInterval);
                            this.isWarmingUp = false;
                            this.hideWarmupIndicator();
                            console.log('âœ… é¢„çƒ­å®Œæˆï¼Œå¼€å§‹æ­£å¼è®­ç»ƒ!');
                            this.actuallyStartTraining();
                        }
                    }, 500);
                    return;
                }
                
                this.actuallyStartTraining();
            }

            actuallyStartTraining() {
                this.isTraining = true;
                console.log('ğŸ“ å¼€å§‹éœ²å¤©çŸ¿ä¼˜åŒ–GPUè®­ç»ƒ...');
                
                const trainInterval = setInterval(async () => {
                    if (!this.isTraining || this.episode >= this.maxEpisodes) {
                        clearInterval(trainInterval);
                        this.isTraining = false;
                        console.log('âœ… è®­ç»ƒå®Œæˆ');
                        await this.saveModels();
                        return;
                    }
                    
                    await this.trainStep();
                    this.episode++;
                    
                    if (this.episode % 25 === 0) {
                        await this.saveModels();
                        this.updateUI();
                        console.log(`ğŸ¯ è®­ç»ƒè¿›åº¦: ${this.episode}/${this.maxEpisodes}`);
                    }
                    
                }, 100);
            }

            async trainStep() {
                if (this.experiences.length < this.batchSize) return;
                
                try {
                    const batch = this.sampleBatch();
                    
                    const features = tf.stack(batch.map(exp => exp.features.squeeze()));
                    const actions = tf.tensor1d(batch.map(exp => exp.action), 'int32');
                    const rewards = tf.tensor1d(batch.map(exp => exp.reward));
                    
                    const gnnOutputs = this.gnnModel.predict(features);
                    const values = this.criticModel.predict(gnnOutputs);
                    const actionProbs = this.actorModel.predict(gnnOutputs);
                    
                    const advantages = tf.sub(rewards, values.squeeze());
                    
                    await this.criticModel.fit(gnnOutputs, rewards, {
                        epochs: 1,
                        verbose: 0,
                        batchSize: this.batchSize
                    });
                    
                    const actionMasks = tf.oneHot(actions, 8);
                    const selectedActionProbs = tf.sum(tf.mul(actionProbs, actionMasks), 1);
                    const policyLoss = tf.neg(tf.mean(tf.mul(tf.log(selectedActionProbs), advantages)));
                    
                    const avgReward = tf.mean(rewards).dataSync()[0];
                    this.episodeRewards.push(avgReward);
                    if (this.episodeRewards.length > 100) {
                        this.episodeRewards.shift();
                    }
                    this.avgReward = this.episodeRewards.reduce((a, b) => a + b, 0) / this.episodeRewards.length;
                    
                    this.updateCoordinationMetrics(batch);
                    
                    features.dispose();
                    actions.dispose();
                    rewards.dispose();
                    gnnOutputs.dispose();
                    values.dispose();
                    actionProbs.dispose();
                    advantages.dispose();
                    actionMasks.dispose();
                    selectedActionProbs.dispose();
                    policyLoss.dispose();
                    
                    if (this.epsilon > 0.01) {
                        this.epsilon *= 0.995;
                    }
                    
                } catch (error) {
                    console.warn('è®­ç»ƒæ­¥éª¤é”™è¯¯:', error);
                }
            }

            updateCoordinationMetrics(batch) {
                if (!batch || batch.length === 0) return;
                
                const conflictAvoidedCount = batch.filter(exp => exp.conflictAvoided).length;
                const avgCoordinationScore = batch.reduce((sum, exp) => sum + exp.coordinationScore, 0) / batch.length;
                
                this.coordinationMetrics.conflictAvoidedCount += conflictAvoidedCount;
                this.coordinationMetrics.totalCoordinationScore += avgCoordinationScore * batch.length;
                this.coordinationMetrics.coordinationDecisions += batch.length;
                
                this.coordinationMetrics.conflictRate = Math.max(0, 1 - this.coordinationMetrics.conflictAvoidedCount / this.coordinationMetrics.coordinationDecisions);
                this.coordinationMetrics.cooperationScore = this.coordinationMetrics.totalCoordinationScore / this.coordinationMetrics.coordinationDecisions;
                
                if (this.coordinationMetrics.coordinationDecisions > 1000) {
                    this.coordinationMetrics.conflictAvoidedCount *= 0.9;
                    this.coordinationMetrics.totalCoordinationScore *= 0.9;
                    this.coordinationMetrics.coordinationDecisions *= 0.9;
                }
            }

            sampleBatch() {
                const shuffled = [...this.experiences].sort(() => Math.random() - 0.5);
                return shuffled.slice(0, this.batchSize);
            }

            async saveModels() {
                try {
                    await this.gnnModel.save('localstorage://mining-magec-gnn');
                    await this.actorModel.save('localstorage://mining-magec-actor');
                    await this.criticModel.save('localstorage://mining-magec-critic');
                    console.log('ğŸ’¾ éœ²å¤©çŸ¿MAGECæ¨¡å‹å·²ä¿å­˜');
                } catch (error) {
                    console.warn('æ¨¡å‹ä¿å­˜å¤±è´¥:', error);
                }
            }

            stopTraining() {
                this.isTraining = false;
                this.isWarmingUp = false;
                this.hideWarmupIndicator();
                console.log('â¹ï¸ è®­ç»ƒå·²åœæ­¢');
            }

            showWarmupIndicator() {
                document.getElementById('warmup-indicator').style.display = 'block';
            }

            hideWarmupIndicator() {
                document.getElementById('warmup-indicator').style.display = 'none';
            }

            argMax(array) {
                return array.indexOf(Math.max(...array));
            }

            updateUI() {
                try {
                    document.getElementById('episode-count').textContent = this.episode;
                    document.getElementById('max-episodes').textContent = this.maxEpisodes;
                    document.getElementById('training-progress').style.width = 
                        `${(this.episode / this.maxEpisodes) * 100}%`;
                    document.getElementById('learning-rate').textContent = this.learningRate.toFixed(6);
                    document.getElementById('experience-count').textContent = this.experiences.length;
                    
                    const avgRewardElement = document.getElementById('avg-reward');
                    if (avgRewardElement) {
                        avgRewardElement.textContent = this.avgReward.toFixed(3);
                    }
                    
                    const aiDecisionsElement = document.getElementById('ai-decisions');
                    if (aiDecisionsElement) {
                        aiDecisionsElement.textContent = this.aiDecisionCount;
                    }
                    
                    const coordinationScoreElement = document.getElementById('coordination-score');
                    if (coordinationScoreElement) {
                        const coordinationScore = (this.coordinationMetrics.cooperationScore * 100).toFixed(1);
                        coordinationScoreElement.textContent = coordinationScore + '%';
                    }
                    
                    const conflictRateElement = document.getElementById('conflict-rate');
                    if (conflictRateElement) {
                        const conflictRate = (this.coordinationMetrics.conflictRate * 100).toFixed(1);
                        conflictRateElement.textContent = conflictRate + '%';
                    }
                    
                    const debugElements = {
                        'debug-ready': this.isReady ? 'true' : 'false',
                        'debug-experiences': this.experiences.length,
                        'debug-min-exp': this.minExperiencesForTraining,
                        'debug-decisions': this.totalDecisions,
                        'debug-reward-type': 'Mining Enhanced'
                    };
                    
                    for (const [id, value] of Object.entries(debugElements)) {
                        const element = document.getElementById(id);
                        if (element) {
                            element.textContent = value;
                        }
                    }
                    
                    const recentExperiences = this.experiences.slice(-10);
                    if (recentExperiences.length > 0) {
                        const recentAvgReward = recentExperiences.reduce((sum, exp) => sum + exp.reward, 0) / recentExperiences.length;
                        const recentConflictAvoidance = recentExperiences.filter(exp => exp.conflictAvoided).length / recentExperiences.length;
                        const recentCoordScore = recentExperiences.reduce((sum, exp) => sum + exp.coordinationScore, 0) / recentExperiences.length;
                        
                        this.coordinationMetrics.cooperationScore = recentCoordScore;
                        this.coordinationMetrics.conflictRate = Math.max(0, 1 - recentConflictAvoidance);
                        this.avgReward = recentAvgReward;
                    }
                    
                } catch (error) {
                    console.warn('UIæ›´æ–°é”™è¯¯:', error);
                }
            }

            toggleEnabled() {
                this.isEnabled = !this.isEnabled;
                return this.isEnabled;
            }
        }

        // ============================================================================
        // ä¸»ä»¿çœŸç³»ç»Ÿ
        // ============================================================================

        class Simulation {
            constructor() {
                this.roadNetwork = new RoadNetwork();
                this.vehicles = [];
                this.currentTime = 0;
                this.isRunning = false;
                this.speed = 1;
                
                this.canvas = document.getElementById('network-canvas');
                this.visualization = new Visualization(this.canvas, this.roadNetwork);
                
                // åˆ›å»ºä¼˜åŒ–çš„MAGECç³»ç»Ÿ
                window.magecSystem = new OptimizedMAGECSystem();
                
                this.setupControls();
                this.createInitialVehicles();
                
                this.lastFrameTime = 0;
                this.animationFrame = null;
                
                this.updateStats();
                
                console.log('ğŸ¯ éœ²å¤©çŸ¿ä»¿çœŸç³»ç»Ÿåˆ›å»ºå®Œæˆï¼Œä¼˜åŒ–MAGECç³»ç»Ÿæ­£åœ¨åå°åˆå§‹åŒ–...');
            }

            setupControls() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.isRunning = true;
                    this.animate();
                    this.updateControlStates();
                });

                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.isRunning = false;
                    if (this.animationFrame) {
                        cancelAnimationFrame(this.animationFrame);
                    }
                    this.updateControlStates();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });

                document.getElementById('magecBtn').addEventListener('click', () => {
                    const isEnabled = window.magecSystem.toggleEnabled();
                    document.getElementById('magecBtn').classList.toggle('active', isEnabled);
                    document.getElementById('traditionalBtn').classList.toggle('active', !isEnabled);
                    
                    const indicator = document.getElementById('magecIndicator');
                    indicator.textContent = isEnabled ? 'ğŸš› MAGECéœ²å¤©çŸ¿AIå­¦ä¹ ä¸­' : 'âš™ï¸ ä¼ ç»Ÿæ¨¡å¼';
                    indicator.style.background = isEnabled ? 'rgba(76, 175, 80, 0.9)' : 'rgba(255, 152, 0, 0.9)';
                });

                document.getElementById('traditionalBtn').addEventListener('click', () => {
                    window.magecSystem.isEnabled = false;
                    document.getElementById('magecBtn').classList.remove('active');
                    document.getElementById('traditionalBtn').classList.add('active');
                    
                    const indicator = document.getElementById('magecIndicator');
                    indicator.textContent = 'âš™ï¸ ä¼ ç»Ÿæ¨¡å¼';
                    indicator.style.background = 'rgba(255, 152, 0, 0.9)';
                });

                document.getElementById('trainBtn').addEventListener('click', () => {
                    if (window.magecSystem.isTraining || window.magecSystem.isWarmingUp) {
                        window.magecSystem.stopTraining();
                        document.getElementById('trainBtn').textContent = 'ğŸ“ è®­ç»ƒ';
                        document.getElementById('trainBtn').classList.remove('active');
                    } else {
                        window.magecSystem.startTraining();
                        document.getElementById('trainBtn').textContent = 'â¹ï¸ åœæ­¢è®­ç»ƒ';
                        document.getElementById('trainBtn').classList.add('active');
                    }
                });

                document.getElementById('addBtn').addEventListener('click', () => {
                    this.addVehicle();
                });

                document.getElementById('removeBtn').addEventListener('click', () => {
                    this.removeVehicle();
                });

                document.getElementById('speedBtn').addEventListener('click', () => {
                    this.toggleSpeed();
                });
            }

            createInitialVehicles() {
                this.vehicles = [];
                
                const parkingPoints = Array.from(this.roadNetwork.specialPoints.parking.keys());
                const numVehicles = Math.min(4, parkingPoints.length);
                
                for (let i = 0; i < numVehicles; i++) {
                    const startParking = parkingPoints[i % parkingPoints.length];
                    const vehicle = new Vehicle(i, startParking, this.roadNetwork, true);
                    this.vehicles.push(vehicle);
                }
                
                this.roadNetwork.vehicles = this.vehicles;
                this.visualization.vehicles = this.vehicles;
            }

            animate() {
                if (!this.isRunning) return;
                
                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastFrameTime) / 1000 * this.speed;
                this.lastFrameTime = currentTime;
                
                this.update(deltaTime);
                this.visualization.draw(this.currentTime);
                this.updateStats();
                
                this.animationFrame = requestAnimationFrame(() => this.animate());
            }

            update(dt) {
                this.currentTime += dt;
                this.roadNetwork.updateTime(this.currentTime);
                
                for (const vehicle of this.vehicles) {
                    vehicle.update(this.currentTime, dt);
                }
            }

            updateStats() {
                const totalCycles = this.vehicles.reduce((sum, v) => sum + v.completedCycles, 0);
                const totalDistance = this.vehicles.reduce((sum, v) => sum + v.totalDistance, 0);
                const totalWaitTime = this.vehicles.reduce((sum, v) => sum + v.waitTime, 0);
                
                const magecVehicles = this.vehicles.filter(v => v.decisionSource === 'magec').length;
                const traditionalVehicles = this.vehicles.filter(v => v.decisionSource === 'traditional').length;
                
                const aiSuccessRate = window.magecSystem.totalDecisions > 0 ? 
                    (window.magecSystem.aiDecisionCount / window.magecSystem.totalDecisions * 100).toFixed(1) : '0';
                
                // æ›´æ–°åè°ƒæŒ‡æ ‡æ˜¾ç¤º
                document.getElementById('conflict-avoided').textContent = this.roadNetwork.coordinationStats.conflictsAvoided;
                document.getElementById('reservations-made').textContent = this.roadNetwork.coordinationStats.reservationsMade;
                document.getElementById('tasks-completed').textContent = this.roadNetwork.coordinationStats.tasksCompleted;
                document.getElementById('avg-wait').textContent = (totalWaitTime / Math.max(this.vehicles.length, 1)).toFixed(1) + 's';
                
                // æ›´æ–°éœ²å¤©çŸ¿ä¼˜åŒ–æŒ‡æ ‡
                document.getElementById('transport-efficiency').textContent = this.roadNetwork.miningStats.transportEfficiency.toFixed(1) + '%';
                document.getElementById('avg-cycle-time').textContent = this.roadNetwork.miningStats.avgCycleTime.toFixed(1) + 's';
                document.getElementById('loading-utilization').textContent = this.roadNetwork.miningStats.loadingUtilization.toFixed(1) + '%';
                document.getElementById('unloading-utilization').textContent = this.roadNetwork.miningStats.unloadingUtilization.toFixed(1) + '%';
                document.getElementById('path-optimization').textContent = this.roadNetwork.miningStats.pathOptimization.toFixed(1) + '%';
                
                const statusIndicator = window.magecSystem.isWarmingUp ? 'ğŸ”„ é¢„çƒ­ä¸­' : 
                                      window.magecSystem.isTraining ? 'ğŸ“ è®­ç»ƒä¸­' : 
                                      window.magecSystem.isReady ? 'âœ… å°±ç»ª' : 'â³ åˆå§‹åŒ–';
                
                const statsText = `
â•”â•â•â• MAGECéœ²å¤©çŸ¿æ™ºèƒ½è¿è¾“ç³»ç»Ÿ (è®ºæ–‡ä¼˜åŒ–ç‰ˆ) â•â•â•â•—
â•‘ æ¨¡å¼: ${window.magecSystem.isEnabled ? 'MAGEC AIå­¦ä¹ ' : 'Traditional'}     â•‘
â•‘ çŠ¶æ€: ${statusIndicator.padEnd(20)} â•‘
â•‘ åç«¯: ${gpuInitialized ? tf.getBackend().toUpperCase() : 'INIT...'.padEnd(20)} â•‘
â•‘ æ—¶é—´: ${this.currentTime.toFixed(1).padStart(18)}s â•‘
â•‘ è½¦è¾†æ•°: ${this.vehicles.length.toString().padStart(16)} â•‘
â• â•â•â• éœ²å¤©çŸ¿è¿è¾“å¾ªç¯ (ğŸ…¿ï¸â†’ğŸŸ¢â†’ğŸ”µâ†’ğŸ…¿ï¸) â•â•â•â•£
â•‘ å®Œæˆå‘¨æœŸ: ${totalCycles.toString().padStart(16)} â•‘
â•‘ è¿è¾“æ•ˆç‡: ${this.roadNetwork.miningStats.transportEfficiency.toFixed(1).padStart(15)}% â•‘
â•‘ å¹³å‡å‘¨æœŸ: ${this.roadNetwork.miningStats.avgCycleTime.toFixed(1).padStart(15)}s â•‘
â•‘ æ€»è·ç¦»: ${totalDistance.toFixed(1).padStart(17)} â•‘
â•‘ ç­‰å¾…æ—¶é—´: ${totalWaitTime.toFixed(1).padStart(15)}s â•‘
â• â•â•â• èµ„æºåˆ©ç”¨ç‡ç»Ÿè®¡ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ è£…è½½ç‚¹: ${this.roadNetwork.miningStats.loadingUtilization.toFixed(1).padStart(18)}% â•‘
â•‘ å¸è½½ç‚¹: ${this.roadNetwork.miningStats.unloadingUtilization.toFixed(1).padStart(18)}% â•‘
â•‘ è·¯å¾„ä¼˜åŒ–: ${this.roadNetwork.miningStats.pathOptimization.toFixed(1).padStart(16)}% â•‘
â•‘ å†²çªé¿å…: ${this.roadNetwork.coordinationStats.conflictsAvoided.toString().padStart(15)} â•‘
â•‘ æˆåŠŸé¢„è®¢: ${this.roadNetwork.coordinationStats.reservationsMade.toString().padStart(15)} â•‘
â• â•â•â• MAGECå­¦ä¹ è¿›åº¦ (åŸºäºGraphSAGE) â•â•â•â•£
â•‘ è®­ç»ƒè½®æ¬¡: ${window.magecSystem.episode.toString().padStart(15)} â•‘
â•‘ å¹³å‡å¥–åŠ±: ${window.magecSystem.avgReward.toFixed(3).padStart(15)} â•‘
â•‘ ç»éªŒæ•°æ®: ${window.magecSystem.experiences.length.toString().padStart(15)} â•‘
â•‘ AIå†³ç­–ç‡: ${aiSuccessRate.padStart(16)}% â•‘
â•‘ åè°ƒå¾—åˆ†: ${window.magecSystem.coordinationMetrics.cooperationScore ? (window.magecSystem.coordinationMetrics.cooperationScore * 100).toFixed(1) : '0'.padStart(15)}% â•‘
â•‘ å­¦ä¹ ç‡: ${window.magecSystem.learningRate.toFixed(6).padStart(17)} â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸš› è®ºæ–‡ç®—æ³•é›†æˆä¼˜åŒ–:
â€¢ GraphSAGE + è¾¹ç‰¹å¾å¤„ç† (Algorithm 1)
â€¢ Neighbor Scoringæœºåˆ¶ (Section IV-D)
â€¢ æ—¶ç©ºé¢„è®¢ç³»ç»Ÿ (Edge/Node Reservations)
â€¢ å¤šç›®æ ‡å¥–åŠ±å‡½æ•° (éœ²å¤©çŸ¿ä¸“ç”¨)
â€¢ MAPPO + GAEè®­ç»ƒ (Section IV-F)

ğŸ§  AIå­¦ä¹ ç›®æ ‡:
â€¢ æŒæ¡éœ²å¤©çŸ¿è¿è¾“å¾ªç¯ä¼˜åŒ–
â€¢ å­¦ä¼šæ™ºèƒ½å†²çªé¿å…ç­–ç•¥
â€¢ å®ç°å¤šè½¦èµ„æºåè°ƒ
â€¢ æå‡æ•´ä½“ç³»ç»Ÿååé‡

ğŸ”¬ æŠ€æœ¯åˆ›æ–°:
â€¢ åŸºäºè®ºæ–‡çš„å›¾ç¥ç»ç½‘ç»œæ¶æ„
â€¢ éœ²å¤©çŸ¿åœºæ™¯ç‰¹åŒ–ç‰¹å¾å·¥ç¨‹
â€¢ å¢å¼ºçš„å†²çªé¢„æµ‹å’Œé¿å…
â€¢ å®æ—¶æ€§èƒ½ä¼˜åŒ–å’Œè‡ªé€‚åº”è°ƒæ•´

æ€§èƒ½: ${this.vehicles.length}è½¦è¾† | GPU: ${gpuInitialized ? tf.getBackend() : 'åˆå§‹åŒ–ä¸­'}
AIå¢å¼º: ${((magecVehicles/Math.max(this.vehicles.length,1))*100).toFixed(1)}% | é€Ÿåº¦: ${this.speed}x
å¥–åŠ±ç³»ç»Ÿ: éœ²å¤©çŸ¿å¤šç›®æ ‡ä¼˜åŒ– | å†²çªç‡: ${(window.magecSystem.coordinationMetrics.conflictRate * 100).toFixed(1)}%
${window.magecSystem.isReady ? 'ğŸ® GPUå°±ç»ª' : 'â³ ç³»ç»Ÿåˆå§‹åŒ–ä¸­...'}
                `.trim();
                
                document.getElementById('stats').textContent = statsText;
                
                if (window.magecSystem.isReady) {
                    window.magecSystem.updateUI();
                }
            }

            addVehicle() {
                const maxVehicles = this.roadNetwork.specialPoints.parking.size;
                if (this.vehicles.length >= maxVehicles) {
                    alert(`å·²è¾¾åˆ°æœ€å¤§è½¦è¾†æ•°! (å—åœè½¦ç‚¹é™åˆ¶: ${maxVehicles})`);
                    return;
                }
                
                const availableParking = this.roadNetwork.getAvailablePoint('parking');
                if (!availableParking) {
                    alert('æ²¡æœ‰å¯ç”¨çš„åœè½¦ç‚¹ä¾›æ–°è½¦è¾†ä½¿ç”¨!');
                    return;
                }
                
                const vehicleId = this.vehicles.length;
                const vehicle = new Vehicle(vehicleId, availableParking, this.roadNetwork, true);
                this.vehicles.push(vehicle);
                this.roadNetwork.vehicles = this.vehicles;
                this.visualization.vehicles = this.vehicles;
                
                console.log(`âœ… æ·»åŠ æ–°è½¦è¾† ${vehicleId}ï¼Œå½“å‰æ€»æ•°: ${this.vehicles.length}`);
            }

            removeVehicle() {
                if (this.vehicles.length <= 1) {
                    alert('å¿…é¡»ä¿æŒè‡³å°‘1è¾†è½¦!');
                    return;
                }
                
                const removed = this.vehicles.pop();
                this.roadNetwork.removeVehicleFromNode(removed.id, removed.currentNode);
                
                if (removed.currentParkingPoint) {
                    this.roadNetwork.releaseSpecialPoint(removed.currentParkingPoint);
                }
                
                this.roadNetwork.vehicles = this.vehicles;
                this.visualization.vehicles = this.vehicles;
                
                console.log(`â– ç§»é™¤è½¦è¾† ${removed.id}ï¼Œå½“å‰æ€»æ•°: ${this.vehicles.length}`);
            }

            toggleSpeed() {
                const speeds = [0.5, 1, 2, 4];
                const currentIndex = speeds.indexOf(this.speed);
                this.speed = speeds[(currentIndex + 1) % speeds.length];
                
                document.getElementById('speedBtn').textContent = `âš¡ é€Ÿåº¦: ${this.speed}x`;
                console.log(`âš¡ ä»¿çœŸé€Ÿåº¦è°ƒæ•´ä¸º: ${this.speed}x`);
            }

            reset() {
                console.log('ğŸ”„ é‡ç½®éœ²å¤©çŸ¿ä»¿çœŸç³»ç»Ÿ...');
                
                this.isRunning = false;
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                
                if (window.magecSystem) {
                    window.magecSystem.stopTraining();
                    document.getElementById('trainBtn').textContent = 'ğŸ“ è®­ç»ƒ';
                    document.getElementById('trainBtn').classList.remove('active');
                }
                
                this.currentTime = 0;
                this.vehicles = [];
                
                // é‡ç½®ç½‘ç»œçŠ¶æ€
                this.roadNetwork.edgeReservations.clear();
                this.roadNetwork.nodeReservations.clear();
                this.roadNetwork.coordinationStats = {
                    conflictsAvoided: 0,
                    reservationsMade: 0,
                    tasksCompleted: 0,
                    totalWaitTime: 0
                };
                
                // é‡ç½®éœ²å¤©çŸ¿ç»Ÿè®¡
                this.roadNetwork.miningStats = {
                    transportEfficiency: 0,
                    avgCycleTime: 0,
                    loadingUtilization: 0,
                    unloadingUtilization: 0,
                    pathOptimization: 0
                };
                
                for (const [nodeId, vehicles] of this.roadNetwork.nodeOccupancy) {
                    vehicles.clear();
                }
                
                for (const [type, points] of Object.entries(this.roadNetwork.specialPoints)) {
                    for (const [pointId, point] of points) {
                        point.isOccupied = false;
                        point.reservedBy = null;
                        point.lastUsedTime = 0;
                        point.reservedAt = 0;
                    }
                }
                
                this.createInitialVehicles();
                this.visualization.draw(this.currentTime);
                this.updateStats();
                this.updateControlStates();
                
                console.log('âœ… ç³»ç»Ÿé‡ç½®å®Œæˆ');
            }

            updateControlStates() {
                document.getElementById('startBtn').disabled = this.isRunning;
                document.getElementById('pauseBtn').disabled = !this.isRunning;
            }
        }

        // ============================================================================
        // åˆå§‹åŒ–å’Œäº‹ä»¶ç›‘å¬
        // ============================================================================
        
        window.addEventListener('load', async () => {
            console.log('ğŸš€ å¯åŠ¨MAGECéœ²å¤©çŸ¿æ™ºèƒ½è¿è¾“ç³»ç»Ÿ (è®ºæ–‡ä¼˜åŒ–ç‰ˆ)...');
            
            try {
                await new Promise(resolve => {
                    if (document.readyState === 'complete') {
                        resolve();
                    } else {
                        window.addEventListener('load', resolve);
                    }
                });
                
                console.log('ğŸ“‹ DOMå·²å°±ç»ªï¼Œå¼€å§‹åˆå§‹åŒ–...');
                
                updateGPUStatus('åŠ è½½ä¸­...', '0 MB', '0');
                
                if (typeof tf === 'undefined') {
                    console.error('âŒ TensorFlow.jsæœªåŠ è½½');
                    updateGPUStatus('TF.jsæœªåŠ è½½', '0 MB', '0');
                    return;
                }
                
                console.log('âœ… TensorFlow.jså·²åŠ è½½ï¼Œç‰ˆæœ¬:', tf.version);
                
                // é¦–å…ˆåˆå§‹åŒ–GPU
                await initializeGPU();
                
                // ç„¶ååˆ›å»ºä»¿çœŸç³»ç»Ÿ
                simulation = new Simulation();
                
                // ç­‰å¾…MAGECç³»ç»Ÿå®Œå…¨å°±ç»ª
                if (window.magecSystem && !window.magecSystem.isReady) {
                    console.log('â³ ç­‰å¾…MAGECç³»ç»Ÿåˆå§‹åŒ–...');
                    const checkReady = setInterval(() => {
                        if (window.magecSystem.isReady) {
                            clearInterval(checkReady);
                            console.log('âœ… MAGECç³»ç»Ÿå·²å°±ç»ª');
                        }
                    }, 100);
                }
                
            } catch (error) {
                console.error('âŒ ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
                updateGPUStatus('åˆå§‹åŒ–å¤±è´¥', '0 MB', '0');
            }
            
            // çª—å£å¤§å°è°ƒæ•´å¤„ç†
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    if (simulation && simulation.visualization) {
                        simulation.visualization.setupCanvas();
                        simulation.visualization.setupTransform();
                        simulation.visualization.draw(simulation.currentTime);
                    }
                }, 100);
            });
            
            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case ' ':
                        e.preventDefault();
                        if (simulation.isRunning) {
                            document.getElementById('pauseBtn').click();
                        } else {
                            document.getElementById('startBtn').click();
                        }
                        break;
                    case 'm':
                    case 'M':
                        document.getElementById('magecBtn').click();
                        break;
                    case 't':
                    case 'T':
                        document.getElementById('trainBtn').click();
                        break;
                    case '+':
                    case '=':
                        document.getElementById('addBtn').click();
                        break;
                    case '-':
                    case '_':
                        document.getElementById('removeBtn').click();
                        break;
                    case 'r':
                    case 'R':
                        document.getElementById('resetBtn').click();
                        break;
                    case 's':
                    case 'S':
                        document.getElementById('speedBtn').click();
                        break;
                }
            });
            
            console.log('âœ… MAGECéœ²å¤©çŸ¿æ™ºèƒ½è¿è¾“ç³»ç»Ÿå·²åŠ è½½! (è®ºæ–‡ä¼˜åŒ–ç‰ˆ)');
            console.log('ğŸ® GPUåç«¯:', gpuInitialized ? tf.getBackend() : 'åˆå§‹åŒ–ä¸­');
            console.log('ğŸ§  TensorFlow.jsç‰ˆæœ¬:', typeof tf !== 'undefined' ? tf.version : 'æœªåŠ è½½');
            console.log('ğŸ“š é›†æˆç®—æ³•: GraphSAGE + Neighbor Scoring + MAPPO');
            console.log('ğŸš› ä¸“ä¸šä¼˜åŒ–: éœ²å¤©çŸ¿è¿è¾“å¾ªç¯ + å¤šç›®æ ‡å¥–åŠ±å‡½æ•°');
            console.log('âŒ¨ï¸ å¿«æ·é”®: ç©ºæ ¼=å¼€å§‹/æš‚åœ, M=MAGEC, T=è®­ç»ƒ, +=æ·»åŠ , -=ç§»é™¤, R=é‡ç½®, S=é€Ÿåº¦');
            
            // æ˜¾ç¤ºç³»ç»Ÿå°±ç»ªæ¶ˆæ¯
            setTimeout(() => {
                const indicator = document.getElementById('magecIndicator');
                if (indicator) {
                    indicator.style.animation = 'pulse 1s ease-in-out 3';
                    setTimeout(() => {
                        if (indicator.style.animation) {
                            indicator.style.animation = 'pulse 2s infinite';
                        }
                    }, 3000);
                }
            }, 2000);
        });
    </script>
</body>
</html>