<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stage 1: åŸºäºæ‹“æ‰‘æ„ŸçŸ¥GNNæ¶æ„çš„éœ²å¤©çŸ¿æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ - æ™ºèƒ½æ‹“æ‰‘æ„å»º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .control-panel {
            background: #f8f9fa;
            padding: 25px;
            border-right: 1px solid #e9ecef;
            overflow-y: auto;
            max-height: 800px;
        }

        .visualization-area {
            padding: 25px;
            background: white;
        }

        .section {
            margin-bottom: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-weight: bold;
            margin-bottom: 12px;
            color: #495057;
            display: flex;
            align-items: center;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 16px;
            background: #007bff;
            margin-right: 8px;
            border-radius: 2px;
        }

        /* ç¯å¢ƒç®¡ç†æ ·å¼ */
        .environment-section {
            border-left: 4px solid #28a745;
        }

        .file-input-container {
            position: relative;
            margin-bottom: 15px;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: block;
            background: #28a745;
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: background 0.3s ease;
            font-size: 14px;
        }

        .file-input-label:hover {
            background: #218838;
        }

        .file-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .file-name {
            font-weight: bold;
            color: #495057;
            margin-bottom: 4px;
        }

        .file-details {
            color: #6c757d;
            font-size: 12px;
        }

        .environment-info {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .info-item:last-child {
            margin-bottom: 0;
        }

        .info-label {
            color: #495057;
        }

        .info-value {
            font-weight: bold;
            color: #28a745;
        }

        .step-container {
            margin-bottom: 20px;
        }

        .step {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .step.active {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .step.completed {
            border-color: #28a745;
            background: #d4edda;
        }

        .step.executing {
            border-color: #ffc107;
            background: #fff3cd;
            animation: pulse 1.5s infinite;
        }

        .step.disabled {
            border-color: #dee2e6;
            background: #f8f9fa;
            cursor: not-allowed;
            opacity: 0.6;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
        }

        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .step-number {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #6c757d;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
        }

        .step.active .step-number {
            background: #007bff;
        }

        .step.completed .step-number {
            background: #28a745;
        }

        .step.executing .step-number {
            background: #ffc107;
            color: #333;
        }

        .step-title {
            font-weight: bold;
            font-size: 14px;
        }

        .step-description {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }

        .step-status {
            font-size: 12px;
            font-weight: bold;
        }

        .controls {
            margin-top: 20px;
        }

        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: background 0.3s ease;
            width: 100%;
        }

        .btn:hover {
            background: #0056b3;
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.secondary:hover {
            background: #545b62;
        }

        .btn.success {
            background: #28a745;
        }

        .btn.success:hover {
            background: #218838;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            background: #f8f9fa;
        }

        #visualCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .mode-selector {
            margin-bottom: 20px;
        }

        .mode-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .canvas-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .canvas-btn {
            padding: 8px 12px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .canvas-btn:hover {
            background: #e9ecef;
        }

        .stats-panel {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .stats-title {
            font-weight: bold;
            margin-bottom: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            width: 0%;
            transition: width 0.5s ease;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border-radius: 2px;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-ready { background: #28a745; }
        .status-executing { background: #ffc107; }
        .status-completed { background: #007bff; }
        .status-waiting { background: #6c757d; }

        .alert {
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .canvas-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Stage 1: æ™ºèƒ½æ‹“æ‰‘æ„å»º</h1>
            <div class="subtitle">åŸºäºæ‹“æ‰‘æ„ŸçŸ¥GNNæ¶æ„çš„éœ²å¤©çŸ¿æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ</div>
        </div>

        <div class="main-content">
            <div class="control-panel">
                <!-- ç¯å¢ƒç®¡ç†åŒºåŸŸ -->
                <div class="section environment-section">
                    <div class="section-title">ğŸ—ºï¸ ç¯å¢ƒç®¡ç†</div>
                    
                    <div class="file-input-container">
                        <input type="file" id="environmentFile" class="file-input" accept=".json" onchange="loadEnvironmentFile(event)">
                        <label for="environmentFile" class="file-input-label">
                            ğŸ“ é€‰æ‹©ç¯å¢ƒæ–‡ä»¶ (JSON)
                        </label>
                    </div>

                    <div id="fileInfo" class="file-info" style="display: none;">
                        <div class="file-name" id="fileName">æœªé€‰æ‹©æ–‡ä»¶</div>
                        <div class="file-details" id="fileDetails">è¯·é€‰æ‹©ä¸€ä¸ªç¯å¢ƒJSONæ–‡ä»¶</div>
                    </div>

                    <button id="loadEnvironmentBtn" class="btn success" onclick="processEnvironment()" disabled>
                        ğŸ”„ åŠ è½½ç¯å¢ƒ
                    </button>

                    <div id="environmentInfo" class="environment-info" style="display: none;">
                        <div class="info-item">
                            <span class="info-label">ç¯å¢ƒå°ºå¯¸:</span>
                            <span class="info-value" id="envDimensions">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">è½¦è¾†æ•°é‡:</span>
                            <span class="info-value" id="envVehicles">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">è£…è½½ç‚¹:</span>
                            <span class="info-value" id="envLoadingPoints">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">å¸è½½ç‚¹:</span>
                            <span class="info-value" id="envUnloadingPoints">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">éšœç¢ç‰©:</span>
                            <span class="info-value" id="envObstacles">-</span>
                        </div>
                    </div>

                    <div id="environmentStatus" class="alert alert-info" style="display: none;">
                        ğŸ“ è¯·é€‰æ‹©å¹¶åŠ è½½ç¯å¢ƒæ–‡ä»¶ä»¥å¼€å§‹æ„å»º
                    </div>
                </div>

                <!-- ç³»ç»ŸçŠ¶æ€ -->
                <div class="section">
                    <div class="section-title">ğŸ“Š ç³»ç»ŸçŠ¶æ€</div>
                    <span id="systemStatus">ç­‰å¾…ç¯å¢ƒåŠ è½½</span>
                </div>

                <!-- æ‰§è¡Œæ­¥éª¤ -->
                <div class="step-container">
                    <h3 style="margin-bottom: 15px;">ğŸ¯ æ‰§è¡Œæ­¥éª¤</h3>
                    
                    <div class="step disabled" id="step1" onclick="executeStep(1)">
                        <div class="step-header">
                            <div class="step-number">1</div>
                            <div class="step-title">åŒå‘è·¯å¾„æ™ºèƒ½è§„åˆ’</div>
                        </div>
                        <div class="step-description">æ··åˆA*ç®—æ³•ç”ŸæˆåŒå‘è·¯å¾„</div>
                        <div class="step-status">
                            <span class="status-indicator status-waiting"></span>
                            <span id="status1">ç­‰å¾…ç¯å¢ƒ</span>
                        </div>
                    </div>

                    <div class="step disabled" id="step2" onclick="executeStep(2)">
                        <div class="step-header">
                            <div class="step-number">2</div>
                            <div class="step-title">åŠ¨æ€èŠ‚ç‚¹å¯†åº¦æ§åˆ¶</div>
                        </div>
                        <div class="step-description">åŸºäºæ›²ç‡çš„è‡ªé€‚åº”èŠ‚ç‚¹ç”Ÿæˆ</div>
                        <div class="step-status">
                            <span class="status-indicator status-waiting"></span>
                            <span id="status2">ç­‰å¾…</span>
                        </div>
                    </div>

                    <div class="step disabled" id="step3" onclick="executeStep(3)">
                        <div class="step-header">
                            <div class="step-number">3</div>
                            <div class="step-title">å…³é”®èŠ‚ç‚¹èšç±»æå–</div>
                        </div>
                        <div class="step-description">å¤šè½®èšç±»è¯†åˆ«æ‹“æ‰‘å…³é”®èŠ‚ç‚¹</div>
                        <div class="step-status">
                            <span class="status-indicator status-waiting"></span>
                            <span id="status3">ç­‰å¾…</span>
                        </div>
                    </div>

                    <div class="step disabled" id="step4" onclick="executeStep(4)">
                        <div class="step-header">
                            <div class="step-number">4</div>
                            <div class="step-title">è½¦è¾†åŠ¨åŠ›å­¦çº¦æŸæ‹Ÿåˆ</div>
                        </div>
                        <div class="step-description">Clothoid-Cubicæ›²çº¿æ‹Ÿåˆ</div>
                        <div class="step-status">
                            <span class="status-indicator status-waiting"></span>
                            <span id="status4">ç­‰å¾…</span>
                        </div>
                    </div>

                    <div class="step disabled" id="step5" onclick="executeStep(5)">
                        <div class="step-header">
                            <div class="step-number">5</div>
                            <div class="step-title">å›¾æ‹“æ‰‘æ ‡å‡†åŒ–è¾“å‡º</div>
                        </div>
                        <div class="step-description">ç”ŸæˆGNNè¾“å…¥æ ¼å¼</div>
                        <div class="step-status">
                            <span class="status-indicator status-waiting"></span>
                            <span id="status5">ç­‰å¾…</span>
                        </div>
                    </div>
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>

                <div class="controls">
                    <button class="btn" id="executeAllBtn" onclick="executeAll()" disabled>æ‰§è¡Œå®Œæ•´æ„å»º</button>
                    <button class="btn secondary" onclick="resetSystem()">é‡ç½®ç³»ç»Ÿ</button>
                </div>

                <div class="stats-panel">
                    <div class="stats-title">ğŸ“Š æ„å»ºç»Ÿè®¡</div>
                    <div class="stat-item">
                        <span>åŸå§‹è·¯å¾„æ•°:</span>
                        <span id="originalPaths">0</span>
                    </div>
                    <div class="stat-item">
                        <span>å…³é”®èŠ‚ç‚¹æ•°:</span>
                        <span id="keyNodes">0</span>
                    </div>
                    <div class="stat-item">
                        <span>èŠ‚ç‚¹å‡å°‘ç‡:</span>
                        <span id="nodeReduction">0%</span>
                    </div>
                    <div class="stat-item">
                        <span>æ‹Ÿåˆè´¨é‡:</span>
                        <span id="fittingQuality">0.0</span>
                    </div>
                    <div class="stat-item">
                        <span>æ„å»ºæ—¶é—´:</span>
                        <span id="buildTime">0s</span>
                    </div>
                </div>
            </div>

            <div class="visualization-area">
                <div class="mode-selector">
                    <label for="displayMode"><strong>ğŸ¨ æ˜¾ç¤ºæ¨¡å¼:</strong></label>
                    <select id="displayMode" onchange="changeDisplayMode()">
                        <option value="environment">ç¯å¢ƒæ¦‚è§ˆ</option>
                        <option value="raw">åŸå§‹éª¨å¹²è·¯å¾„</option>
                        <option value="clustered">èšç±»å…³é”®èŠ‚ç‚¹</option>
                        <option value="reconstructed">é‡å»ºé“è·¯ç½‘ç»œ</option>
                    </select>
                </div>

                <div class="canvas-controls">
                    <button class="canvas-btn" onclick="resetView()">ğŸ”„ é‡ç½®è§†å›¾</button>
                    <button class="canvas-btn" onclick="fitToScreen()">ğŸ“ é€‚åº”å±å¹•</button>
                    <button class="canvas-btn" onclick="exportImage()">ğŸ’¾ å¯¼å‡ºå›¾åƒ</button>
                </div>

                <div class="canvas-container">
                    <canvas id="visualCanvas" width="800" height="600"></canvas>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4CAF50;"></div>
                        <span>è£…è½½ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF9800;"></div>
                        <span>å¸è½½ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2196F3;"></div>
                        <span>åœè½¦åŒº</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9E9E9E;"></div>
                        <span>éšœç¢ç‰©</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #E91E63;"></div>
                        <span>è½¦è¾†</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFC107;"></div>
                        <span>å…³é”®èŠ‚ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9C27B0;"></div>
                        <span>é‡å»ºé“è·¯</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€çŠ¶æ€
        let systemState = {
            currentStep: 0,
            completedSteps: [],
            isExecuting: false,
            displayMode: 'environment',
            canvas: null,
            ctx: null,
            
            // ç¯å¢ƒæ•°æ®
            environmentLoaded: false,
            environment: {
                width: 500,
                height: 500,
                vehicles: [],
                obstacles: [],
                loading_points: [],
                unloading_points: [],
                parking_areas: []
            },
            
            // è§†å›¾æ§åˆ¶
            viewTransform: {
                scale: 1.0,
                offsetX: 0,
                offsetY: 0,
                minScale: 0.1,
                maxScale: 5.0
            },
            
            // è·¯å¾„æ•°æ®
            rawPaths: [],
            keyNodes: [],
            reconstructedPaths: [],
            
            // ç»Ÿè®¡æ•°æ®
            stats: {
                originalPaths: 0,
                keyNodes: 0,
                nodeReduction: 0,
                fittingQuality: 0.0,
                buildTime: 0
            }
        };

        // åˆå§‹åŒ–ç³»ç»Ÿ
        function initSystem() {
            systemState.canvas = document.getElementById('visualCanvas');
            systemState.ctx = systemState.canvas.getContext('2d');
            
            // è°ƒæ•´canvaså°ºå¯¸
            resizeCanvas();
            
            // ç»˜åˆ¶åˆå§‹åœºæ™¯
            drawScene();
            
            // æ·»åŠ canvasäº¤äº’äº‹ä»¶
            setupCanvasInteraction();
            
            // ç›‘å¬çª—å£å°ºå¯¸å˜åŒ–
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const container = systemState.canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            systemState.canvas.width = rect.width - 2;
            systemState.canvas.height = rect.height - 2;
            
            if (systemState.ctx) {
                drawScene();
            }
        }

        function setupCanvasInteraction() {
            const canvas = systemState.canvas;
            let isDragging = false;
            let lastX, lastY;

            // é¼ æ ‡æ»šè½®ç¼©æ”¾
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = systemState.viewTransform.scale * scaleFactor;
                
                if (newScale >= systemState.viewTransform.minScale && 
                    newScale <= systemState.viewTransform.maxScale) {
                    
                    // ç¼©æ”¾åˆ°é¼ æ ‡ä½ç½®
                    systemState.viewTransform.offsetX = mouseX - (mouseX - systemState.viewTransform.offsetX) * scaleFactor;
                    systemState.viewTransform.offsetY = mouseY - (mouseY - systemState.viewTransform.offsetY) * scaleFactor;
                    systemState.viewTransform.scale = newScale;
                    
                    drawScene();
                }
            });

            // é¼ æ ‡æ‹–æ‹½å¹³ç§»
            canvas.addEventListener('mousedown', function(e) {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                canvas.style.cursor = 'grabbing';
            });

            canvas.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;
                    
                    systemState.viewTransform.offsetX += deltaX;
                    systemState.viewTransform.offsetY += deltaY;
                    
                    lastX = e.clientX;
                    lastY = e.clientY;
                    
                    drawScene();
                }
            });

            canvas.addEventListener('mouseup', function(e) {
                isDragging = false;
                canvas.style.cursor = 'crosshair';
            });

            canvas.addEventListener('mouseleave', function(e) {
                isDragging = false;
                canvas.style.cursor = 'crosshair';
            });
        }

        // ç¯å¢ƒæ–‡ä»¶åŠ è½½
        function loadEnvironmentFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileDetails').textContent = `å¤§å°: ${(file.size / 1024).toFixed(1)} KB | ç±»å‹: ${file.type}`;
            document.getElementById('fileInfo').style.display = 'block';
            document.getElementById('loadEnvironmentBtn').disabled = false;

            // æ›´æ–°çŠ¶æ€
            document.getElementById('environmentStatus').innerHTML = 'ğŸ“ æ–‡ä»¶å·²é€‰æ‹©ï¼Œç‚¹å‡»"åŠ è½½ç¯å¢ƒ"æŒ‰é’®å¤„ç†';
            document.getElementById('environmentStatus').className = 'alert alert-info';
            document.getElementById('environmentStatus').style.display = 'block';
        }

        function processEnvironment() {
            const fileInput = document.getElementById('environmentFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('è¯·å…ˆé€‰æ‹©ç¯å¢ƒæ–‡ä»¶');
                return;
            }

            document.getElementById('loadEnvironmentBtn').disabled = true;
            document.getElementById('environmentStatus').innerHTML = 'ğŸ”„ æ­£åœ¨åŠ è½½ç¯å¢ƒæ•°æ®...';
            document.getElementById('environmentStatus').className = 'alert alert-info';

            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const environmentData = JSON.parse(e.target.result);
                    parseEnvironmentData(environmentData);
                    
                    // æˆåŠŸåŠ è½½
                    systemState.environmentLoaded = true;
                    
                    // æ›´æ–°UI
                    updateEnvironmentInfo();
                    enableSteps();
                    
                    // æ˜¾ç¤ºç¯å¢ƒ
                    document.getElementById('displayMode').value = 'environment';
                    systemState.displayMode = 'environment';
                    
                    // è‡ªé€‚åº”è§†å›¾
                    fitToScreen();
                    drawScene();
                    
                    document.getElementById('environmentStatus').innerHTML = 'âœ… ç¯å¢ƒåŠ è½½æˆåŠŸï¼ç°åœ¨å¯ä»¥å¼€å§‹æ„å»º';
                    document.getElementById('environmentStatus').className = 'alert alert-success';
                    
                    updateSystemStatus('ç¯å¢ƒå·²åŠ è½½ï¼Œç³»ç»Ÿå°±ç»ª');

                } catch (error) {
                    console.error('ç¯å¢ƒåŠ è½½å¤±è´¥:', error);
                    document.getElementById('environmentStatus').innerHTML = `âŒ ç¯å¢ƒåŠ è½½å¤±è´¥: ${error.message}`;
                    document.getElementById('environmentStatus').className = 'alert alert-warning';
                }
                
                document.getElementById('loadEnvironmentBtn').disabled = false;
            };

            reader.onerror = function() {
                document.getElementById('environmentStatus').innerHTML = 'âŒ æ–‡ä»¶è¯»å–å¤±è´¥';
                document.getElementById('environmentStatus').className = 'alert alert-warning';
                document.getElementById('loadEnvironmentBtn').disabled = false;
            };

            reader.readAsText(file);
        }

        function parseEnvironmentData(data) {
            // é‡ç½®ç¯å¢ƒæ•°æ®
            systemState.environment = {
                width: data.width || 500,
                height: data.height || 500,
                vehicles: [],
                obstacles: [],
                loading_points: [],
                unloading_points: [],
                parking_areas: []
            };

            console.log('è§£æç¯å¢ƒæ•°æ®:', data);

            // è§£æéšœç¢ç‰©
            if (data.obstacles && Array.isArray(data.obstacles)) {
                systemState.environment.obstacles = data.obstacles.map(obs => {
                    if (typeof obs === 'object' && obs.x !== undefined && obs.y !== undefined) {
                        return {
                            x: parseFloat(obs.x),
                            y: parseFloat(obs.y),
                            width: parseFloat(obs.width || 1),
                            height: parseFloat(obs.height || 1)
                        };
                    }
                    return null;
                }).filter(obs => obs !== null);
            }

            // è§£æè£…è½½ç‚¹
            if (data.loading_points && Array.isArray(data.loading_points)) {
                systemState.environment.loading_points = data.loading_points.map((point, index) => {
                    if (typeof point === 'object' && point.x !== undefined && point.y !== undefined) {
                        return {
                            x: parseFloat(point.x),
                            y: parseFloat(point.y),
                            theta: parseFloat(point.theta || 0),
                            id: `L${index + 1}`
                        };
                    } else if (Array.isArray(point) && point.length >= 2) {
                        return {
                            x: parseFloat(point[1]), // æ³¨æ„ï¼šå¯èƒ½æ˜¯row,colæ ¼å¼
                            y: parseFloat(point[0]),
                            theta: parseFloat(point[2] || 0),
                            id: `L${index + 1}`
                        };
                    }
                    return null;
                }).filter(point => point !== null);
            }

            // è§£æå¸è½½ç‚¹
            if (data.unloading_points && Array.isArray(data.unloading_points)) {
                systemState.environment.unloading_points = data.unloading_points.map((point, index) => {
                    if (typeof point === 'object' && point.x !== undefined && point.y !== undefined) {
                        return {
                            x: parseFloat(point.x),
                            y: parseFloat(point.y),
                            theta: parseFloat(point.theta || 0),
                            id: `U${index + 1}`
                        };
                    } else if (Array.isArray(point) && point.length >= 2) {
                        return {
                            x: parseFloat(point[1]),
                            y: parseFloat(point[0]),
                            theta: parseFloat(point[2] || 0),
                            id: `U${index + 1}`
                        };
                    }
                    return null;
                }).filter(point => point !== null);
            }

            // è§£æåœè½¦åŒº
            if (data.parking_areas && Array.isArray(data.parking_areas)) {
                systemState.environment.parking_areas = data.parking_areas.map((point, index) => {
                    if (typeof point === 'object' && point.x !== undefined && point.y !== undefined) {
                        return {
                            x: parseFloat(point.x),
                            y: parseFloat(point.y),
                            theta: parseFloat(point.theta || 0),
                            id: `P${index + 1}`
                        };
                    } else if (Array.isArray(point) && point.length >= 2) {
                        return {
                            x: parseFloat(point[1]),
                            y: parseFloat(point[0]),
                            theta: parseFloat(point[2] || 0),
                            id: `P${index + 1}`
                        };
                    }
                    return null;
                }).filter(point => point !== null);
            }

            // è§£æè½¦è¾†
            if (data.vehicles && Array.isArray(data.vehicles)) {
                systemState.environment.vehicles = data.vehicles.map(vehicle => {
                    return {
                        id: vehicle.id || `V${systemState.environment.vehicles.length + 1}`,
                        x: parseFloat(vehicle.x || 0),
                        y: parseFloat(vehicle.y || 0),
                        theta: parseFloat(vehicle.theta || 0),
                        type: vehicle.type || 'dump_truck',
                        load: parseFloat(vehicle.load || 0),
                        max_load: parseFloat(vehicle.max_load || 100),
                        status: vehicle.status || 'idle'
                    };
                });
            } else if (data.vehicles_info && Array.isArray(data.vehicles_info)) {
                // å¤„ç†å¦ä¸€ç§æ ¼å¼
                systemState.environment.vehicles = data.vehicles_info.map(vehicle => {
                    return {
                        id: vehicle.id || `V${systemState.environment.vehicles.length + 1}`,
                        x: parseFloat(vehicle.x || 0),
                        y: parseFloat(vehicle.y || 0),
                        theta: parseFloat(vehicle.theta || 0),
                        type: vehicle.type || 'dump_truck',
                        load: parseFloat(vehicle.load || 0),
                        max_load: parseFloat(vehicle.max_load || 100),
                        status: vehicle.status || 'idle'
                    };
                });
            }

            console.log('è§£æå®Œæˆçš„ç¯å¢ƒæ•°æ®:', systemState.environment);
        }

        function updateEnvironmentInfo() {
            const env = systemState.environment;
            
            document.getElementById('envDimensions').textContent = `${env.width} Ã— ${env.height}`;
            document.getElementById('envVehicles').textContent = env.vehicles.length;
            document.getElementById('envLoadingPoints').textContent = env.loading_points.length;
            document.getElementById('envUnloadingPoints').textContent = env.unloading_points.length;
            document.getElementById('envObstacles').textContent = env.obstacles.length;
            
            document.getElementById('environmentInfo').style.display = 'block';
        }

        function enableSteps() {
            // å¯ç”¨ç¬¬ä¸€æ­¥
            const step1 = document.getElementById('step1');
            step1.classList.remove('disabled');
            document.getElementById('status1').textContent = 'å°±ç»ª';
            
            document.getElementById('executeAllBtn').disabled = false;
        }

        // ç»˜åˆ¶åœºæ™¯
        function drawScene() {
            const ctx = systemState.ctx;
            const width = systemState.canvas.width;
            const height = systemState.canvas.height;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);
            
            // åº”ç”¨å˜æ¢
            ctx.save();
            ctx.translate(systemState.viewTransform.offsetX, systemState.viewTransform.offsetY);
            ctx.scale(systemState.viewTransform.scale, systemState.viewTransform.scale);
            
            // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
            drawGrid();
            
            // æ ¹æ®æ˜¾ç¤ºæ¨¡å¼ç»˜åˆ¶å†…å®¹
            if (systemState.environmentLoaded) {
                switch (systemState.displayMode) {
                    case 'environment':
                        drawEnvironmentOverview();
                        break;
                    case 'raw':
                        drawEnvironmentBackground();
                        drawRawPaths();
                        break;
                    case 'clustered':
                        drawEnvironmentBackground();
                        drawRawPaths(0.3); // åŠé€æ˜æ˜¾ç¤ºåŸå§‹è·¯å¾„
                        drawKeyNodes();
                        break;
                    case 'reconstructed':
                        drawEnvironmentBackground();
                        drawReconstructedPaths();
                        drawKeyNodes();
                        break;
                }
            } else {
                drawPlaceholder();
            }
            
            ctx.restore();
            
            // ç»˜åˆ¶çŠ¶æ€ä¿¡æ¯
            drawStatusInfo();
        }

        function drawGrid() {
            if (!systemState.environmentLoaded) return;
            
            const ctx = systemState.ctx;
            const env = systemState.environment;
            const gridSize = 50;
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5 / systemState.viewTransform.scale;
            
            // å‚ç›´çº¿
            for (let x = 0; x <= env.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, env.height);
                ctx.stroke();
            }
            
            // æ°´å¹³çº¿
            for (let y = 0; y <= env.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(env.width, y);
                ctx.stroke();
            }
            
            // è¾¹ç•Œ
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2 / systemState.viewTransform.scale;
            ctx.strokeRect(0, 0, env.width, env.height);
        }

        function drawEnvironmentOverview() {
            drawEnvironmentBackground();
        }

        function drawEnvironmentBackground() {
            const ctx = systemState.ctx;
            const env = systemState.environment;
            
            // ç»˜åˆ¶éšœç¢ç‰©
            ctx.fillStyle = '#9E9E9E';
            env.obstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width || 5, obstacle.height || 5);
            });
            
            // ç»˜åˆ¶è£…è½½ç‚¹
            ctx.fillStyle = '#4CAF50';
            env.loading_points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // æ ‡ç­¾
                ctx.fillStyle = 'white';
                ctx.font = `bold ${12 / systemState.viewTransform.scale}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(point.id, point.x, point.y + 3);
                ctx.fillStyle = '#4CAF50';
            });
            
            // ç»˜åˆ¶å¸è½½ç‚¹
            ctx.fillStyle = '#FF9800';
            env.unloading_points.forEach(point => {
                const size = 16;
                ctx.fillRect(point.x - size/2, point.y - size/2, size, size);
                
                // æ ‡ç­¾
                ctx.fillStyle = 'white';
                ctx.font = `bold ${12 / systemState.viewTransform.scale}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(point.id, point.x, point.y + 3);
                ctx.fillStyle = '#FF9800';
            });
            
            // ç»˜åˆ¶åœè½¦åŒº
            ctx.fillStyle = '#2196F3';
            env.parking_areas.forEach(point => {
                const size = 12;
                ctx.fillRect(point.x - size/2, point.y - size/2, size, size);
                
                // æ ‡ç­¾
                ctx.fillStyle = 'white';
                ctx.font = `bold ${10 / systemState.viewTransform.scale}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(point.id, point.x, point.y + 3);
                ctx.fillStyle = '#2196F3';
            });
            
            // ç»˜åˆ¶è½¦è¾†
            ctx.fillStyle = '#E91E63';
            env.vehicles.forEach(vehicle => {
                ctx.save();
                ctx.translate(vehicle.x, vehicle.y);
                ctx.rotate(vehicle.theta);
                
                const width = 6;
                const height = 3;
                ctx.fillRect(-width/2, -height/2, width, height);
                
                ctx.restore();
                
                // è½¦è¾†ID
                ctx.fillStyle = '#333';
                ctx.font = `${8 / systemState.viewTransform.scale}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(vehicle.id, vehicle.x, vehicle.y - 10);
                ctx.fillStyle = '#E91E63';
            });
        }

        function drawRawPaths(alpha = 1.0) {
            const ctx = systemState.ctx;
            ctx.globalAlpha = alpha;
            
            systemState.rawPaths.forEach((path, index) => {
                const colors = ['#2196F3', '#E91E63', '#00BCD4', '#4CAF50', '#FF5722'];
                ctx.strokeStyle = colors[index % colors.length];
                ctx.lineWidth = 2 / systemState.viewTransform.scale;
                
                if (path.points && path.points.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(path.points[0].x, path.points[0].y);
                    
                    for (let i = 1; i < path.points.length; i++) {
                        ctx.lineTo(path.points[i].x, path.points[i].y);
                    }
                    
                    ctx.stroke();
                    
                    // ç»˜åˆ¶è·¯å¾„èŠ‚ç‚¹
                    ctx.fillStyle = ctx.strokeStyle;
                    path.points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 1.5 / systemState.viewTransform.scale, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            });
            
            ctx.globalAlpha = 1.0;
        }

        function drawKeyNodes() {
            const ctx = systemState.ctx;
            
            systemState.keyNodes.forEach(node => {
                if (node.isEndpoint) {
                    ctx.fillStyle = '#F44336';
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 6 / systemState.viewTransform.scale, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#FFC107';
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 4 / systemState.viewTransform.scale, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // ç»˜åˆ¶èŠ‚ç‚¹è¿æ¥
                ctx.strokeStyle = '#9E9E9E';
                ctx.lineWidth = 1 / systemState.viewTransform.scale;
                ctx.setLineDash([3, 3]);
                
                if (node.connections) {
                    node.connections.forEach(connId => {
                        const connNode = systemState.keyNodes.find(n => n.id === connId);
                        if (connNode) {
                            ctx.beginPath();
                            ctx.moveTo(node.x, node.y);
                            ctx.lineTo(connNode.x, connNode.y);
                            ctx.stroke();
                        }
                    });
                }
                
                ctx.setLineDash([]);
            });
        }

        function drawReconstructedPaths() {
            const ctx = systemState.ctx;
            
            systemState.reconstructedPaths.forEach((path, index) => {
                const colors = ['#9C27B0', '#673AB7', '#3F51B5', '#009688', '#795548'];
                ctx.strokeStyle = colors[index % colors.length];
                ctx.lineWidth = 3 / systemState.viewTransform.scale;
                
                // ç»˜åˆ¶å¹³æ»‘æ›²çº¿
                if (path.points && path.points.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(path.points[0].x, path.points[0].y);
                    
                    for (let i = 1; i < path.points.length - 1; i++) {
                        const cp1x = (path.points[i - 1].x + path.points[i].x) / 2;
                        const cp1y = (path.points[i - 1].y + path.points[i].y) / 2;
                        const cp2x = (path.points[i].x + path.points[i + 1].x) / 2;
                        const cp2y = (path.points[i].y + path.points[i + 1].y) / 2;
                        
                        ctx.quadraticCurveTo(path.points[i].x, path.points[i].y, cp2x, cp2y);
                    }
                    
                    ctx.lineTo(path.points[path.points.length - 1].x, path.points[path.points.length - 1].y);
                    ctx.stroke();
                }
            });
        }

        function drawPlaceholder() {
            const ctx = systemState.ctx;
            const canvas = systemState.canvas;
            
            ctx.fillStyle = '#666';
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('è¯·å…ˆåŠ è½½ç¯å¢ƒæ–‡ä»¶', canvas.width / 2, canvas.height / 2);
            
            ctx.fillStyle = '#999';
            ctx.font = '16px sans-serif';
            ctx.fillText('é€‰æ‹©JSONæ ¼å¼çš„ç¯å¢ƒæ–‡ä»¶å¼€å§‹æ„å»º', canvas.width / 2, canvas.height / 2 + 40);
        }

        function drawStatusInfo() {
            const ctx = systemState.ctx;
            const width = systemState.canvas.width;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(width - 220, 10, 200, 100);
            
            ctx.fillStyle = 'white';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            
            const info = [
                `æ¨¡å¼: ${getDisplayModeText()}`,
                `ç¼©æ”¾: ${(systemState.viewTransform.scale * 100).toFixed(0)}%`,
                `ç¯å¢ƒ: ${systemState.environmentLoaded ? 'å·²åŠ è½½' : 'æœªåŠ è½½'}`,
                `è·¯å¾„: ${systemState.rawPaths.length}`,
                `å…³é”®èŠ‚ç‚¹: ${systemState.keyNodes.length}`,
                `æ­¥éª¤: ${systemState.completedSteps.length}/5`
            ];
            
            info.forEach((text, index) => {
                ctx.fillText(text, width - 210, 30 + index * 15);
            });
        }

        function getDisplayModeText() {
            switch (systemState.displayMode) {
                case 'environment': return 'ç¯å¢ƒæ¦‚è§ˆ';
                case 'raw': return 'åŸå§‹è·¯å¾„';
                case 'clustered': return 'èšç±»èŠ‚ç‚¹';
                case 'reconstructed': return 'é‡å»ºé“è·¯';
                default: return 'æœªçŸ¥';
            }
        }

        // è§†å›¾æ§åˆ¶
        function resetView() {
            systemState.viewTransform = {
                scale: 1.0,
                offsetX: 0,
                offsetY: 0,
                minScale: 0.1,
                maxScale: 5.0
            };
            drawScene();
        }

        function fitToScreen() {
            if (!systemState.environmentLoaded) return;
            
            const canvas = systemState.canvas;
            const env = systemState.environment;
            
            const padding = 50;
            const scaleX = (canvas.width - padding * 2) / env.width;
            const scaleY = (canvas.height - padding * 2) / env.height;
            const scale = Math.min(scaleX, scaleY);
            
            systemState.viewTransform.scale = Math.max(systemState.viewTransform.minScale, 
                                                      Math.min(systemState.viewTransform.maxScale, scale));
            systemState.viewTransform.offsetX = (canvas.width - env.width * systemState.viewTransform.scale) / 2;
            systemState.viewTransform.offsetY = (canvas.height - env.height * systemState.viewTransform.scale) / 2;
            
            drawScene();
        }

        function exportImage() {
            const canvas = systemState.canvas;
            const link = document.createElement('a');
            link.download = `topology_stage1_${new Date().getTime()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        // æ­¥éª¤æ‰§è¡Œé€»è¾‘ï¼ˆåŸºäºç¯å¢ƒæ•°æ®ï¼‰
        function executeStep(stepNumber) {
            if (systemState.isExecuting) return;
            
            if (!systemState.environmentLoaded) {
                alert('è¯·å…ˆåŠ è½½ç¯å¢ƒæ–‡ä»¶');
                return;
            }
            
            // æ£€æŸ¥å‰ç½®æ¡ä»¶
            if (stepNumber > 1 && !systemState.completedSteps.includes(stepNumber - 1)) {
                alert(`è¯·å…ˆå®Œæˆæ­¥éª¤ ${stepNumber - 1}`);
                return;
            }
            
            systemState.isExecuting = true;
            systemState.currentStep = stepNumber;
            
            updateStepUI(stepNumber, 'executing');
            updateSystemStatus(`æ­£åœ¨æ‰§è¡Œæ­¥éª¤ ${stepNumber}...`);
            
            setTimeout(() => {
                executeStepLogic(stepNumber);
            }, 500);
        }

        function executeStepLogic(stepNumber) {
            const startTime = Date.now();
            
            switch (stepNumber) {
                case 1:
                    generateRawPaths();
                    break;
                case 2:
                    optimizeNodeDensity();
                    break;
                case 3:
                    performClustering();
                    break;
                case 4:
                    performCurveFitting();
                    break;
                case 5:
                    standardizeTopology();
                    break;
            }
            
            const endTime = Date.now();
            const duration = (endTime - startTime) / 1000;
            
            systemState.completedSteps.push(stepNumber);
            systemState.isExecuting = false;
            
            updateStepUI(stepNumber, 'completed');
            updateProgress();
            updateStats();
            drawScene();
            
            // å¯ç”¨ä¸‹ä¸€æ­¥
            if (stepNumber < 5) {
                enableStep(stepNumber + 1);
            }
            
            updateSystemStatus(`æ­¥éª¤ ${stepNumber} å®Œæˆ (${duration.toFixed(1)}s)`);
            
            setTimeout(() => {
                if (stepNumber === 5) {
                    updateSystemStatus('ğŸ‰ Stage 1 æ™ºèƒ½æ‹“æ‰‘æ„å»ºå®Œæˆï¼');
                } else {
                    updateSystemStatus('å°±ç»ª');
                }
            }, 2000);
        }

        function generateRawPaths() {
            systemState.rawPaths = [];
            const env = systemState.environment;
            
            // åŸºäºå®é™…ç¯å¢ƒæ•°æ®ç”Ÿæˆè·¯å¾„
            const loading = env.loading_points;
            const unloading = env.unloading_points;
            
            // ç”Ÿæˆè£…è½½ç‚¹åˆ°å¸è½½ç‚¹çš„è·¯å¾„
            loading.forEach((loadPoint, i) => {
                unloading.forEach((unloadPoint, j) => {
                    const path = createPath(loadPoint, unloadPoint, `L${i+1}_U${j+1}`);
                    systemState.rawPaths.push(path);
                });
            });
            
            // æ·»åŠ ä¸€äº›åœè½¦åŒºè·¯å¾„
            const parking = env.parking_areas;
            loading.forEach((loadPoint, i) => {
                if (i < parking.length) {
                    const path = createPath(loadPoint, parking[i], `L${i+1}_P${i+1}`);
                    systemState.rawPaths.push(path);
                }
            });
            
            systemState.stats.originalPaths = systemState.rawPaths.length;
        }

        function createPath(start, end, id) {
            const points = [];
            const steps = 8 + Math.floor(Math.random() * 5);
            const env = systemState.environment;
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const noise = (Math.random() - 0.5) * 20;
                
                let x = start.x + t * (end.x - start.x) + noise * Math.sin(t * Math.PI);
                let y = start.y + t * (end.y - start.y) + noise * Math.cos(t * Math.PI);
                
                // ç¡®ä¿è·¯å¾„ç‚¹åœ¨ç¯å¢ƒè¾¹ç•Œå†…
                x = Math.max(10, Math.min(x, env.width - 10));
                y = Math.max(10, Math.min(y, env.height - 10));
                
                points.push({ x, y });
            }
            
            return {
                id: id,
                points: points,
                quality: 0.6 + Math.random() * 0.3
            };
        }

        function optimizeNodeDensity() {
            // ä¼˜åŒ–èŠ‚ç‚¹å¯†åº¦ï¼ˆæ¨¡æ‹Ÿï¼‰
            systemState.rawPaths.forEach(path => {
                // å‡å°‘ä¸€äº›èŠ‚ç‚¹
                if (path.points.length > 6) {
                    const newPoints = [];
                    for (let i = 0; i < path.points.length; i += 2) {
                        newPoints.push(path.points[i]);
                    }
                    if (newPoints[newPoints.length - 1] !== path.points[path.points.length - 1]) {
                        newPoints.push(path.points[path.points.length - 1]);
                    }
                    path.points = newPoints;
                }
            });
        }

        function performClustering() {
            systemState.keyNodes = [];
            const allPoints = [];
            const env = systemState.environment;
            
            // æ”¶é›†æ‰€æœ‰è·¯å¾„ç‚¹
            systemState.rawPaths.forEach(path => {
                path.points.forEach((point, index) => {
                    if (index > 0 && index < path.points.length - 1) {
                        allPoints.push({
                            x: point.x,
                            y: point.y,
                            pathId: path.id,
                            isEndpoint: false
                        });
                    }
                });
            });
            
            // æ·»åŠ ç«¯ç‚¹ï¼ˆåŸºäºå®é™…ç¯å¢ƒæ•°æ®ï¼‰
            env.loading_points.forEach(point => {
                systemState.keyNodes.push({
                    x: point.x,
                    y: point.y,
                    id: point.id,
                    isEndpoint: true,
                    type: 'loading'
                });
            });
            
            env.unloading_points.forEach(point => {
                systemState.keyNodes.push({
                    x: point.x,
                    y: point.y,
                    id: point.id,
                    isEndpoint: true,
                    type: 'unloading'
                });
            });
            
            // ç®€å•èšç±»ï¼šé€‰æ‹©ä¸€äº›å…³é”®ç‚¹
            const clusterRadius = Math.min(env.width, env.height) * 0.15;
            const visited = new Set();
            
            allPoints.forEach((point, index) => {
                if (visited.has(index)) return;
                
                const cluster = [point];
                visited.add(index);
                
                // æŸ¥æ‰¾é™„è¿‘çš„ç‚¹
                allPoints.forEach((otherPoint, otherIndex) => {
                    if (visited.has(otherIndex)) return;
                    
                    const distance = Math.sqrt(
                        Math.pow(point.x - otherPoint.x, 2) + 
                        Math.pow(point.y - otherPoint.y, 2)
                    );
                    
                    if (distance < clusterRadius) {
                        cluster.push(otherPoint);
                        visited.add(otherIndex);
                    }
                });
                
                if (cluster.length >= 2) {
                    // è®¡ç®—èšç±»ä¸­å¿ƒ
                    const centerX = cluster.reduce((sum, p) => sum + p.x, 0) / cluster.length;
                    const centerY = cluster.reduce((sum, p) => sum + p.y, 0) / cluster.length;
                    
                    systemState.keyNodes.push({
                        x: centerX,
                        y: centerY,
                        id: `K${systemState.keyNodes.length}`,
                        isEndpoint: false,
                        clusterSize: cluster.length
                    });
                }
            });
            
            systemState.stats.keyNodes = systemState.keyNodes.length;
            const originalNodes = systemState.rawPaths.reduce((sum, path) => sum + path.points.length, 0);
            systemState.stats.nodeReduction = Math.round((1 - systemState.keyNodes.length / originalNodes) * 100);
        }

        function performCurveFitting() {
            systemState.reconstructedPaths = [];
            
            // åŸºäºå…³é”®èŠ‚ç‚¹é‡å»ºè·¯å¾„
            const endpointNodes = systemState.keyNodes.filter(node => node.isEndpoint);
            const loadingNodes = endpointNodes.filter(node => node.type === 'loading');
            const unloadingNodes = endpointNodes.filter(node => node.type === 'unloading');
            
            loadingNodes.forEach((loadNode, i) => {
                unloadingNodes.forEach((unloadNode, j) => {
                    const path = createSmoothPath(loadNode, unloadNode, `R${i}_${j}`);
                    systemState.reconstructedPaths.push(path);
                });
            });
            
            systemState.stats.fittingQuality = 0.75 + Math.random() * 0.2;
        }

        function createSmoothPath(start, end, id) {
            const points = [];
            const keyNodes = systemState.keyNodes.filter(node => !node.isEndpoint);
            
            // é€‰æ‹©1-2ä¸ªä¸­é—´å…³é”®èŠ‚ç‚¹
            const intermediateNodes = [];
            if (keyNodes.length > 0 && Math.random() > 0.3) {
                const randomNode = keyNodes[Math.floor(Math.random() * keyNodes.length)];
                intermediateNodes.push(randomNode);
            }
            
            const pathNodes = [start, ...intermediateNodes, end];
            
            // ç”Ÿæˆå¹³æ»‘è·¯å¾„
            for (let i = 0; i < pathNodes.length - 1; i++) {
                const segmentPoints = generateSmoothSegment(pathNodes[i], pathNodes[i + 1]);
                if (i === 0) {
                    points.push(...segmentPoints);
                } else {
                    points.push(...segmentPoints.slice(1)); // é¿å…é‡å¤ç‚¹
                }
            }
            
            return {
                id: id,
                points: points,
                quality: 0.8 + Math.random() * 0.15
            };
        }

        function generateSmoothSegment(start, end) {
            const points = [];
            const steps = 12;
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const smoothT = t * t * (3 - 2 * t); // å¹³æ»‘å‡½æ•°
                
                points.push({
                    x: start.x + smoothT * (end.x - start.x),
                    y: start.y + smoothT * (end.y - start.y)
                });
            }
            
            return points;
        }

        function standardizeTopology() {
            // æ ‡å‡†åŒ–æ‹“æ‰‘ï¼ˆæ¨¡æ‹Ÿæœ€ç»ˆå¤„ç†ï¼‰
            systemState.stats.buildTime = (Math.random() * 3 + 2).toFixed(1);
            
            // ä¸ºå…³é”®èŠ‚ç‚¹æ·»åŠ è¿æ¥ä¿¡æ¯
            systemState.keyNodes.forEach(node => {
                if (!node.isEndpoint) {
                    node.connections = [];
                    systemState.keyNodes.forEach(otherNode => {
                        if (otherNode !== node) {
                            const distance = Math.sqrt(
                                Math.pow(node.x - otherNode.x, 2) + 
                                Math.pow(node.y - otherNode.y, 2)
                            );
                            const maxDistance = Math.min(systemState.environment.width, systemState.environment.height) * 0.3;
                            if (distance < maxDistance && Math.random() > 0.6) {
                                node.connections.push(otherNode.id);
                            }
                        }
                    });
                }
            });
        }

        function executeAll() {
            if (systemState.isExecuting) return;
            
            if (!systemState.environmentLoaded) {
                alert('è¯·å…ˆåŠ è½½ç¯å¢ƒæ–‡ä»¶');
                return;
            }
            
            let currentStep = 1;
            
            function executeNext() {
                if (currentStep <= 5) {
                    executeStep(currentStep);
                    
                    setTimeout(() => {
                        currentStep++;
                        executeNext();
                    }, 1500);
                }
            }
            
            executeNext();
        }

        function resetSystem() {
            systemState.currentStep = 0;
            systemState.completedSteps = [];
            systemState.isExecuting = false;
            systemState.rawPaths = [];
            systemState.keyNodes = [];
            systemState.reconstructedPaths = [];
            
            systemState.stats = {
                originalPaths: 0,
                keyNodes: 0,
                nodeReduction: 0,
                fittingQuality: 0.0,
                buildTime: 0
            };
            
            // é‡ç½®UI
            for (let i = 1; i <= 5; i++) {
                updateStepUI(i, 'waiting');
                const step = document.getElementById(`step${i}`);
                step.classList.remove('active', 'completed', 'executing');
                step.classList.add('disabled');
            }
            
            if (systemState.environmentLoaded) {
                enableSteps();
            }
            
            updateProgress();
            updateStats();
            updateSystemStatus(systemState.environmentLoaded ? 'ç³»ç»Ÿå·²é‡ç½®ï¼Œç¯å¢ƒå·²ä¿æŒ' : 'ç³»ç»Ÿå·²é‡ç½®');
            drawScene();
        }

        function changeDisplayMode() {
            systemState.displayMode = document.getElementById('displayMode').value;
            drawScene();
        }

        function updateStepUI(stepNumber, status) {
            const step = document.getElementById(`step${stepNumber}`);
            const statusSpan = document.getElementById(`status${stepNumber}`);
            const indicator = step.querySelector('.status-indicator');
            
            step.classList.remove('active', 'completed', 'executing', 'disabled');
            indicator.classList.remove('status-ready', 'status-executing', 'status-completed', 'status-waiting');
            
            switch (status) {
                case 'executing':
                    step.classList.add('executing');
                    indicator.classList.add('status-executing');
                    statusSpan.textContent = 'æ‰§è¡Œä¸­...';
                    break;
                case 'completed':
                    step.classList.add('completed');
                    indicator.classList.add('status-completed');
                    statusSpan.textContent = 'å·²å®Œæˆ';
                    break;
                case 'waiting':
                    step.classList.add('disabled');
                    indicator.classList.add('status-waiting');
                    statusSpan.textContent = 'ç­‰å¾…';
                    break;
                default:
                    indicator.classList.add('status-ready');
                    statusSpan.textContent = 'å°±ç»ª';
            }
        }

        function enableStep(stepNumber) {
            if (stepNumber <= 5) {
                const step = document.getElementById(`step${stepNumber}`);
                const statusSpan = document.getElementById(`status${stepNumber}`);
                const indicator = step.querySelector('.status-indicator');
                
                step.classList.remove('disabled');
                indicator.classList.remove('status-waiting');
                indicator.classList.add('status-ready');
                statusSpan.textContent = 'å°±ç»ª';
            }
        }

        function updateProgress() {
            const progress = (systemState.completedSteps.length / 5) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;
        }

        function updateStats() {
            document.getElementById('originalPaths').textContent = systemState.stats.originalPaths;
            document.getElementById('keyNodes').textContent = systemState.stats.keyNodes;
            document.getElementById('nodeReduction').textContent = `${systemState.stats.nodeReduction}%`;
            document.getElementById('fittingQuality').textContent = systemState.stats.fittingQuality.toFixed(2);
            document.getElementById('buildTime').textContent = `${systemState.stats.buildTime}s`;
        }

        function updateSystemStatus(status) {
            document.getElementById('systemStatus').textContent = status;
        }

        // åˆå§‹åŒ–ç³»ç»Ÿ
        document.addEventListener('DOMContentLoaded', () => {
            initSystem();
        });
    </script>
</body>
</html>